<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPG Signal Recorder</title>
    <meta name="theme-color" content="#2563eb">
    <link rel="manifest" href="data:application/json,{
        'name': 'PPG Signal Recorder',
        'short_name': 'PPG Recorder',
        'description': 'Professional smartphone-based photoplethysmography signal recording',
        'start_url': '/',
        'display': 'standalone',
        'background_color': '#ffffff',
        'theme_color': '#2563eb',
        'icons': [
            {
                'src': 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%232563eb%22 width=%22100%22 height=%22100%22/><path fill=%22white%22 d=%22M20 50 L35 35 L50 50 L65 35 L80 50 L65 65 L50 50 L35 65 Z%22/></svg>',
                'sizes': '192x192',
                'type': 'image/svg+xml'
            }
        ]
    }">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }
        
        .device-setup {
            text-align: center;
        }
        
        .device-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .device-btn {
            padding: 15px 30px;
            border: 2px solid #2563eb;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .device-btn.active {
            background: #2563eb;
            color: white;
        }
        
        .device-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .camera-container {
            position: relative;
            margin: 20px 0;
        }
        
        .camera-view {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .roi-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .roi-rectangle {
            position: absolute;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .roi-circle {
            position: absolute;
            border: 3px solid #00ff00;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }
        
        .roi-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .roi-btn {
            padding: 10px 20px;
            border: 2px solid #2563eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .roi-btn.active {
            background: #2563eb;
            color: white;
        }
        
        .signal-quality {
            text-align: center;
        }
        
        .quality-meter {
            width: 200px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            margin: 15px auto;
            overflow: hidden;
            position: relative;
        }
        
        .quality-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa44 50%, #44ff44 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .quality-text {
            margin-top: 10px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .ppg-display {
            margin-top: 20px;
        }
        
        .ppg-canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 10px;
            border: 2px solid #333;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #2563eb;
        }
        
        .recording-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #2563eb;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-danger {
            background: #dc2626;
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .recording-indicator {
            display: none;
            text-align: center;
            color: #dc2626;
            font-weight: bold;
            font-size: 1.2rem;
            margin: 10px 0;
        }
        
        .recording-indicator.active {
            display: block;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #2563eb;
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .debug-panel {
            margin-top: 20px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .debug-header {
            padding: 15px;
            background: #e9ecef;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-content {
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            display: none;
        }
        
        .debug-content.open {
            display: block;
        }
        
        .flash-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fbbf24;
            border: 2px solid #f59e0b;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .flash-indicator.active {
            opacity: 1;
            box-shadow: 0 0 20px #fbbf24;
        }
        
        .status-message {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .status-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #f59e0b;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        
        .download-section {
            margin-top: 20px;
            text-align: center;
        }
        
        .results-preview {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PPG Signal Recorder</h1>
            <p>Professional smartphone-based photoplethysmography recording</p>
        </div>
        
        <div class="main-grid">
            <div class="card">
                <div class="device-setup">
                    <h3>Device Configuration</h3>
                    <div class="device-buttons">
                        <button class="device-btn active" id="androidBtn">Android</button>
                        <button class="device-btn" id="iosBtn">iOS</button>
                    </div>
                    
                    <div class="camera-container">
                        <div class="camera-view">
                            <video id="cameraFeed" autoplay muted playsinline></video>
                            <canvas id="processingCanvas" style="display: none;"></canvas>
                            <div class="roi-overlay">
                                <div id="roiRectangle" class="roi-rectangle"></div>
                                <div id="roiCircle" class="roi-circle" style="display: none;"></div>
                            </div>
                            <div class="flash-indicator" id="flashIndicator"></div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>ROI Type:</label>
                            <div class="roi-type-selector">
                                <button class="roi-btn active" id="rectangleRoi">Rectangle</button>
                                <button class="roi-btn" id="circularRoi">Circular</button>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI X Position:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiX" min="10" max="90" value="25">
                                <span class="slider-value" id="roiXValue">25%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Y Position:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiY" min="10" max="90" value="25">
                                <span class="slider-value" id="roiYValue">25%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Width:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiWidth" min="20" max="80" value="50">
                                <span class="slider-value" id="roiWidthValue">50%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Height:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiHeight" min="20" max="80" value="50">
                                <span class="slider-value" id="roiHeightValue">50%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Recording Duration:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="recordingDuration" min="5" max="30" value="10" step="5">
                                <span class="slider-value" id="recordingDurationValue">10s</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="signal-quality">
                    <h3>Signal Quality Monitor</h3>
                    
                    <div class="quality-meter">
                        <div class="quality-bar" id="qualityBar"></div>
                    </div>
                    <div class="quality-text" id="qualityText">Android selected - click Start Camera</div>
                    
                    <div class="status-message status-info" id="statusMessage">
                        Android selected by default. Click Start Camera to begin.
                    </div>
                    
                    <div class="ppg-display">
                        <canvas class="ppg-canvas" id="ppgCanvas"></canvas>
                        
                        <div class="metrics">
                            <div class="metric">
                                <div class="metric-label">Heart Rate</div>
                                <div class="metric-value" id="heartRate">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">SNR (dB)</div>
                                <div class="metric-value" id="snrValue">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Signal Strength</div>
                                <div class="metric-value" id="signalStrength">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">DC Component</div>
                                <div class="metric-value" id="dcComponent">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="recording-controls">
                <button class="btn btn-secondary" id="startCameraBtn">Start Camera</button>
                <button class="btn btn-primary" id="startSQMBtn" disabled>Start Signal Monitor</button>
                <button class="btn btn-primary" id="startRecordingBtn" disabled>Start Recording</button>
                <button class="btn btn-danger" id="stopRecordingBtn" disabled>Stop</button>
                <button class="btn btn-secondary" id="calibrateBtn" disabled>Calibrate ZLO</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>
            </div>
            
            <div class="recording-indicator" id="recordingIndicator">
                RECORDING IN PROGRESS...
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="card download-section" id="downloadSection" style="display: none;">
            <h3>Recording Results</h3>
            <div class="results-preview" id="resultsPreview"></div>
            <button class="btn btn-primary" id="downloadBtn">Download PPG Data</button>
        </div>
        
        <div class="card">
            <div class="debug-panel">
                <div class="debug-header" id="debugHeader">Debug Information (Click to toggle)</div>
                <div class="debug-content" id="debugContent"></div>
            </div>
        </div>
    </div>

    <script>
        class PPGRecorder {
            constructor() {
                this.stream = null;
                this.video = document.getElementById('cameraFeed');
                this.canvas = document.getElementById('processingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ppgCanvas = document.getElementById('ppgCanvas');
                this.ppgCtx = this.ppgCanvas.getContext('2d');
                
                this.isRecording = false;
                this.isCalibrating = false;
                this.isCameraActive = false;
                this.isProcessing = false;
                this.recordingData = [];
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.sampleRate = 30;
                this.bufferSize = 300;
                
                // FIXED: Set Android as default
                this.deviceType = 'android';
                this.roiType = 'rectangle';
                this.roiParams = { x: 25, y: 25, width: 50, height: 50 };
                this.zlo = { red: 0, green: 0, blue: 0 };
                
                this.qualityThreshold = 0.7; // FIXED: Adjusted for new signal quality logic
                this.signalQuality = 0;
                this.heartRate = 0;
                this.snr = 0;
                
                // Timer handling
                this.sqmStartTime = null;
                this.sqmTimeoutDuration = 30000; // 30 seconds
                this.sqmTimeoutTimer = null;
                this.sqmCountdownTimer = null;
                this.recordingStartTime = null;
                
                this.initializeEventListeners();
                this.initializeCanvases();
                this.startDebugLog();
                // FIXED: Show ROI overlay immediately on page load
                this.updateROIDisplay();
                
                // Initialize with Android pre-selected
                this.debugLog('PPG Recorder initialized with Android pre-selected and ROI overlay visible');
            }
            
            initializeEventListeners() {
                // Device selection
                document.getElementById('androidBtn').addEventListener('click', () => this.selectDevice('android'));
                document.getElementById('iosBtn').addEventListener('click', () => this.selectDevice('ios'));
                
                // Camera controls
                document.getElementById('startCameraBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('startSQMBtn').addEventListener('click', () => this.startSQM());
                document.getElementById('startRecordingBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecordingBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrateZLO());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSystem());
                
                // ROI controls
                document.getElementById('rectangleRoi').addEventListener('click', () => this.setRoiType('rectangle'));
                document.getElementById('circularRoi').addEventListener('click', () => this.setRoiType('circular'));
                
                // Sliders
                const sliders = ['roiX', 'roiY', 'roiWidth', 'roiHeight', 'recordingDuration'];
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    slider.addEventListener('input', (e) => this.updateSlider(id, e.target.value));
                });
                
                // Debug panel toggle
                document.getElementById('debugHeader').addEventListener('click', () => {
                    const content = document.getElementById('debugContent');
                    content.classList.toggle('open');
                });
                
                // Download button
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadResults());
            }
            
            initializeCanvases() {
                this.ppgCanvas.width = this.ppgCanvas.offsetWidth;
                this.ppgCanvas.height = this.ppgCanvas.offsetHeight;
                this.drawPPGGrid();
            }
            
            selectDevice(type) {
                this.deviceType = type;
                document.querySelectorAll('.device-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Btn').classList.add('active');
                
                this.debugLog(`Selected device type: ${type}`);
                
                if (type === 'ios') {
                    this.updateStatus('iOS detected: Limited camera control available', 'warning');
                } else {
                    this.updateStatus('Android selected: Full camera control available', 'info');
                }
            }
            
            async startCamera() {
                try {
                    this.updateStatus('Requesting camera access...', 'info');
                    
                    const constraints = this.getCameraConstraints();
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    this.video.addEventListener('loadedmetadata', () => {
                        this.setupProcessing();
                        this.isCameraActive = true;
                        this.updateStatus('Camera started. Ready for ZLO calibration or signal monitoring.', 'success');
                        document.getElementById('startCameraBtn').disabled = true;
                        document.getElementById('calibrateBtn').disabled = false;
                        document.getElementById('startSQMBtn').disabled = false;
                        document.getElementById('qualityText').textContent = 'Camera ready - click Start Signal Monitor';
                    });
                    
                } catch (error) {
                    this.debugLog(`Camera error: ${error.message}`);
                    this.updateStatus('Camera access denied or unavailable', 'error');
                }
            }
            
            getCameraConstraints() {
                const baseConstraints = {
                    video: {
                        facingMode: { exact: 'environment' },
                        width: { ideal: 1920, min: 640 },
                        height: { ideal: 1080, min: 480 },
                        frameRate: { ideal: 30, min: 15 }
                    }
                };
                
                if (this.deviceType === 'android') {
                    baseConstraints.video.exposureMode = 'manual';
                    baseConstraints.video.whiteBalanceMode = 'manual';
                    baseConstraints.video.colorTemperature = 3000;
                } else if (this.deviceType === 'ios') {
                    baseConstraints.video.exposureMode = 'continuous';
                    baseConstraints.video.focusMode = 'continuous';
                }
                
                return baseConstraints;
            }
            
            setupProcessing() {
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.enableFlash();
            }
            
            async enableFlash() {
                try {
                    const track = this.stream.getVideoTracks()[0];
                    const capabilities = track.getCapabilities();
                    
                    if (capabilities.torch) {
                        await track.applyConstraints({
                            advanced: [{ torch: true }]
                        });
                        document.getElementById('flashIndicator').classList.add('active');
                        this.debugLog('Flash enabled successfully');
                    } else {
                        this.debugLog('Flash not supported on this device');
                        this.updateStatus('Flash not available - results may be less accurate', 'warning');
                    }
                } catch (error) {
                    this.debugLog(`Flash error: ${error.message}`);
                }
            }
            
            // FIXED: Manual SQM start with working timer
            startSQM() {
                if (!this.isCameraActive) {
                    this.updateStatus('Please start camera first', 'error');
                    return;
                }
                
                // Clear any previous data
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.signalQuality = 0;
                this.heartRate = 0;
                
                // FIXED: Use Date.now() for reliable timing
                this.sqmStartTime = Date.now();
                this.isProcessing = true;
                
                // Start processing loop
                this.processingLoop();
                
                // FIXED: Start 30-second timeout
                this.sqmTimeoutTimer = setTimeout(() => {
                    this.handleSQMTimeout();
                }, this.sqmTimeoutDuration);
                
                // FIXED: Start countdown display
                this.sqmCountdownTimer = setInterval(() => {
                    this.updateCountdown();
                }, 1000);
                
                document.getElementById('startSQMBtn').disabled = true;
                document.getElementById('startSQMBtn').textContent = 'Monitoring...';
                
                this.updateStatus('SQM started - 30 seconds to find good signal. Place finger over rear camera with flash.', 'info');
                document.getElementById('qualityText').textContent = 'Monitoring - 30s remaining';
                
                this.debugLog(`SQM started at ${new Date(this.sqmStartTime).toLocaleTimeString()}`);
            }
            
            // FIXED: Working countdown timer
            updateCountdown() {
                if (!this.sqmStartTime || !this.isProcessing) {
                    if (this.sqmCountdownTimer) {
                        clearInterval(this.sqmCountdownTimer);
                        this.sqmCountdownTimer = null;
                    }
                    return;
                }
                
                const elapsed = Date.now() - this.sqmStartTime;
                const remaining = Math.max(0, Math.ceil((this.sqmTimeoutDuration - elapsed) / 1000));
                const currentQuality = Math.round(this.signalQuality * 100);
                
                if (remaining > 0) {
                    document.getElementById('qualityText').textContent = `Monitoring - ${remaining}s remaining (${currentQuality}%)`;
                } else {
                    document.getElementById('qualityText').textContent = `Timeout - ${currentQuality}% final quality`;
                    clearInterval(this.sqmCountdownTimer);
                    this.sqmCountdownTimer = null;
                }
                
                this.debugLog(`Timer: ${remaining}s remaining, quality: ${currentQuality}%`);
            }
            
            // FIXED: Proper timeout handling
            handleSQMTimeout() {
                this.debugLog(`SQM timeout after 30 seconds. Final quality: ${(this.signalQuality * 100).toFixed(1)}%`);
                
                this.sqmTimeoutTimer = null;
                if (this.sqmCountdownTimer) {
                    clearInterval(this.sqmCountdownTimer);
                    this.sqmCountdownTimer = null;
                }
                
                // FIXED: Always enable recording after timeout
                document.getElementById('startRecordingBtn').disabled = false;
                
                if (this.signalQuality >= this.qualityThreshold) {
                    this.updateStatus('Timeout reached with GOOD signal - ready to record!', 'success');
                    document.getElementById('startRecordingBtn').textContent = 'Start Recording';
                    document.getElementById('startRecordingBtn').style.background = '#2563eb';
                } else {
                    this.updateStatus('Timeout reached with POOR signal - you can still record or reset.', 'warning');
                    document.getElementById('startRecordingBtn').textContent = 'Record Anyway (Poor Quality)';
                    document.getElementById('startRecordingBtn').style.background = '#f59e0b';
                }
                document.getElementById('startRecordingBtn').style.color = 'white';
            }
            
            processingLoop() {
                if (!this.video.paused && !this.video.ended && this.stream && this.isCameraActive && this.isProcessing) {
                    this.processFrame();
                    requestAnimationFrame(() => this.processingLoop());
                } else if (this.isCameraActive && this.isProcessing) {
                    requestAnimationFrame(() => this.processingLoop());
                }
            }
            
            processFrame() {
                if (this.isCalibrating) return;
                
                try {
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    const roiData = this.extractROI();
                    const signal = this.calculatePPGSignal(roiData);
                    const correctedSignal = this.applyZLOCorrection(signal);
                    this.updateSignalBuffer(correctedSignal);
                    this.assessSignalQuality();
                    this.updatePPGDisplay();
                    this.updateMetrics();
                    this.updateROIDisplay();
                    this.checkRecordingReadiness();
                } catch (error) {
                    this.debugLog(`Processing error: ${error.message}`);
                }
            }
            
            extractROI() {
                const x = Math.floor((this.roiParams.x / 100) * this.canvas.width);
                const y = Math.floor((this.roiParams.y / 100) * this.canvas.height);
                const width = Math.floor((this.roiParams.width / 100) * this.canvas.width);
                const height = Math.floor((this.roiParams.height / 100) * this.canvas.height);
                
                if (this.roiType === 'rectangle') {
                    return this.ctx.getImageData(x, y, width, height);
                } else {
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;
                    const radius = Math.min(width, height) / 2;
                    
                    const imageData = this.ctx.getImageData(x, y, width, height);
                    const circularData = new ImageData(width, height);
                    
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const pixelX = (i / 4) % width;
                        const pixelY = Math.floor((i / 4) / width);
                        const distance = Math.sqrt((pixelX - width/2) ** 2 + (pixelY - height/2) ** 2);
                        
                        if (distance <= radius) {
                            circularData.data[i] = imageData.data[i];
                            circularData.data[i + 1] = imageData.data[i + 1];
                            circularData.data[i + 2] = imageData.data[i + 2];
                            circularData.data[i + 3] = imageData.data[i + 3];
                        }
                    }
                    
                    return circularData;
                }
            }
            
            calculatePPGSignal(imageData) {
                const data = imageData.data;
                let redSum = 0, greenSum = 0, blueSum = 0;
                let pixelCount = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) {
                        redSum += data[i];
                        greenSum += data[i + 1];
                        blueSum += data[i + 2];
                        pixelCount++;
                    }
                }
                
                if (pixelCount === 0) return { red: 0, green: 0, blue: 0 };
                
                return {
                    red: redSum / pixelCount,
                    green: greenSum / pixelCount,
                    blue: blueSum / pixelCount
                };
            }
            
            // FIXED: Proper ZLO correction application
            applyZLOCorrection(signal) {
                // Apply Zero Light Offset correction to each channel
                const corrected = {
                    red: Math.max(0, signal.red - this.zlo.red),
                    green: Math.max(0, signal.green - this.zlo.green), 
                    blue: Math.max(0, signal.blue - this.zlo.blue)
                };
                
                this.debugLog(`ZLO Applied - Raw: R=${signal.red.toFixed(1)}, G=${signal.green.toFixed(1)}, B=${signal.blue.toFixed(1)} | Corrected: R=${corrected.red.toFixed(1)}, G=${corrected.green.toFixed(1)}, B=${corrected.blue.toFixed(1)}`);
                
                return corrected;
            }
            
            // FIXED: Proper PPG signal processing
            updateSignalBuffer(signal) {
                const timestamp = Date.now();
                
                // Use GREEN channel for PPG (best penetration and heartbeat detection)
                const ppgValue = signal.green;
                
                // Add to signal buffer for PPG analysis
                this.signalBuffer.push(ppgValue);
                this.timeBuffer.push(timestamp);
                
                // Maintain buffer size (10 seconds at 30fps)
                if (this.signalBuffer.length > this.bufferSize) {
                    this.signalBuffer.shift();
                    this.timeBuffer.shift();
                }
                
                // Store for recording if active
                if (this.isRecording) {
                    this.recordingData.push({
                        timestamp: timestamp,
                        red: signal.red,
                        green: signal.green,
                        blue: signal.blue,
                        ppgValue: ppgValue,
                        quality: this.signalQuality
                    });
                }
                
                // Debug PPG signal processing
                if (this.signalBuffer.length > 0) {
                    const recentDC = this.signalBuffer.slice(-30).reduce((a, b) => a + b, 0) / 30; // Last 1 second average
                    this.debugLog(`PPG Processing - Green: ${ppgValue.toFixed(1)}, Recent DC: ${recentDC.toFixed(1)}, Buffer size: ${this.signalBuffer.length}`);
                }
            }
            
            // PROPERLY FIXED: Correct PPG signal quality assessment
            assessSignalQuality() {
                if (this.signalBuffer.length < 60) {
                    this.signalQuality = 0;
                    return;
                }
                
                const signal = this.signalBuffer.slice(-60);
                const dc = signal.reduce((a, b) => a + b, 0) / signal.length;
                const variance = signal.reduce((sum, val) => sum + (val - dc) ** 2, 0) / signal.length;
                const ac = Math.sqrt(variance);
                const acDcRatio = dc > 0 ? ac / dc : 0;
                
                // CORRECT PPG LOGIC: LOW DC values = finger covering camera = GOOD
                // HIGH DC values = environmental light leaking = BAD
                
                let qualityScore = 0;
                let statusMessage = '';
                let coverageAnalysis = '';
                
                if (dc >= 0.1 && dc <= 5) {
                    // LOW VALUES (0.1-5) = Finger covering camera properly = EXCELLENT
                    qualityScore = 0.9;
                    coverageAnalysis = 'EXCELLENT PPG SIGNAL';
                    statusMessage = `Perfect finger coverage (DC=${dc.toFixed(1)}) - Excellent PPG quality`;
                    
                    // Bonus for heartbeat detection
                    if (acDcRatio >= 0.05 && acDcRatio <= 0.3) {
                        qualityScore = 1.0;
                        statusMessage += ' with clear heartbeat';
                    }
                    
                } else if (dc > 5 && dc <= 15) {
                    // LOW-MEDIUM VALUES (5-15) = Good finger coverage = GOOD
                    qualityScore = 0.7;
                    coverageAnalysis = 'GOOD PPG SIGNAL';
                    statusMessage = `Good finger coverage (DC=${dc.toFixed(1)}) - Suitable for PPG recording`;
                    
                    // Bonus for heartbeat detection
                    if (acDcRatio >= 0.03 && acDcRatio <= 0.25) {
                        qualityScore = 0.8;
                        statusMessage += ' with heartbeat detected';
                    }
                    
                } else if (dc > 15 && dc <= 40) {
                    // MEDIUM VALUES (15-40) = Partial coverage = FAIR
                    qualityScore = 0.5;
                    coverageAnalysis = 'PARTIAL COVERAGE';
                    statusMessage = `Partial finger coverage (DC=${dc.toFixed(1)}) - Some light leaking in`;
                    
                } else if (dc > 40 && dc <= 100) {
                    // HIGH VALUES (40-100) = Poor coverage = POOR
                    qualityScore = 0.3;
                    coverageAnalysis = 'POOR COVERAGE';
                    statusMessage = `Poor finger coverage (DC=${dc.toFixed(1)}) - Too much light leaking`;
                    
                } else {
                    // VERY HIGH VALUES (>100) = Uncovered camera = BAD
                    qualityScore = 0.1;
                    coverageAnalysis = 'UNCOVERED CAMERA';
                    statusMessage = `Uncovered camera (DC=${dc.toFixed(1)}) - Cover with finger for PPG`;
                }
                
                this.signalQuality = qualityScore;
                this.snr = ac > 0.01 ? 20 * Math.log10(Math.max(dc, 0.1) / Math.max(ac, 0.01)) : 0;
                
                this.currentCoverageStatus = statusMessage;
                this.currentCoverageType = coverageAnalysis;
                
                this.debugLog(`PPG: ${coverageAnalysis}, DC=${dc.toFixed(2)}, AC=${ac.toFixed(3)}, AC/DC=${(acDcRatio*100).toFixed(1)}%, Quality=${(qualityScore*100).toFixed(1)}%`);
            }
            
            calculateStabilityQuality() {
                if (this.signalBuffer.length < 90) return 0;
                
                const recent = this.signalBuffer.slice(-90, -60);
                const current = this.signalBuffer.slice(-60);
                
                const recentMean = recent.reduce((a, b) => a + b, 0) / recent.length;
                const currentMean = current.reduce((a, b) => a + b, 0) / current.length;
                
                const stability = 1 - Math.abs(recentMean - currentMean) / Math.max(recentMean, currentMean, 1);
                return Math.max(0, stability);
            }
            
            // FIXED: Heart rate detection optimized for very low DC values (like user's <1.0)
            calculateHeartRate() {
                if (this.signalBuffer.length < 120) return 0;
                
                const signal = this.signalBuffer.slice(-120); // Last 4 seconds
                const sampleRate = 30;
                
                // For very low DC values, use relative peak detection
                const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
                const detrended = signal.map(val => val - mean);
                
                // Adaptive threshold based on signal characteristics
                const signalStd = this.calculateStandardDeviation(detrended);
                
                // For very low DC (user's case: <1.0), use lower threshold
                let threshold;
                if (mean < 5) {
                    threshold = signalStd * 0.1; // Very sensitive for low signals
                } else if (mean < 20) {
                    threshold = signalStd * 0.2; // Moderate sensitivity
                } else {
                    threshold = signalStd * 0.3; // Normal sensitivity
                }
                
                const peaks = [];
                const minPeakDistance = 12; // ~0.4s minimum between peaks
                let lastPeakIndex = -minPeakDistance;
                
                // Find peaks in detrended signal
                for (let i = 3; i < detrended.length - 3; i++) {
                    if (detrended[i] > detrended[i-1] && 
                        detrended[i] > detrended[i+1] && 
                        detrended[i] > detrended[i-2] && 
                        detrended[i] > detrended[i+2] &&
                        detrended[i] > detrended[i-3] && 
                        detrended[i] > detrended[i+3] &&
                        detrended[i] > threshold &&
                        (i - lastPeakIndex) >= minPeakDistance) {
                        
                        peaks.push(i);
                        lastPeakIndex = i;
                    }
                }
                
                if (peaks.length < 2) {
                    this.debugLog(`Heart Rate: Only ${peaks.length} peaks found (threshold: ${threshold.toFixed(3)}, mean: ${mean.toFixed(2)}, std: ${signalStd.toFixed(3)})`);
                    return 0;
                }
                
                // Calculate intervals and filter outliers
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i] - peaks[i-1]);
                }
                
                // Remove outliers (keep middle 60% of intervals)
                intervals.sort((a, b) => a - b);
                const start = Math.floor(intervals.length * 0.2);
                const end = Math.floor(intervals.length * 0.8);
                const validIntervals = intervals.slice(start, end);
                
                if (validIntervals.length === 0) {
                    this.debugLog('Heart Rate: No valid intervals after outlier removal');
                    return 0;
                }
                
                const medianInterval = validIntervals[Math.floor(validIntervals.length / 2)];
                const bpm = (60 * sampleRate) / medianInterval;
                
                if (bpm >= 40 && bpm <= 180) {
                    this.debugLog(`Heart Rate: ${bpm.toFixed(1)} BPM (${peaks.length} peaks, DC: ${mean.toFixed(2)}, threshold: ${threshold.toFixed(3)})`);
                    return Math.round(bpm);
                } else {
                    this.debugLog(`Heart Rate: ${bpm.toFixed(1)} BPM out of range, rejecting`);
                    return 0;
                }
            }
            
            // FIXED: Improved PPG peak detection
            findPPGPeaks(signal) {
                const peaks = [];
                const minPeakDistance = 12; // Minimum ~0.4 seconds between peaks (150 BPM max)
                const maxPeakDistance = 60; // Maximum ~2 seconds between peaks (30 BPM min)
                
                // Calculate dynamic threshold based on signal characteristics
                const signalStd = this.calculateStandardDeviation(signal);
                const threshold = signalStd * 0.3; // Peaks must be above 30% of standard deviation
                
                let lastPeakIndex = -minPeakDistance;
                
                // Find local maxima that exceed threshold
                for (let i = 2; i < signal.length - 2; i++) {
                    const current = signal[i];
                    
                    // Check if this is a local maximum
                    if (current > signal[i-1] && 
                        current > signal[i+1] && 
                        current > signal[i-2] && 
                        current > signal[i+2] && 
                        current > threshold &&
                        (i - lastPeakIndex) >= minPeakDistance) {
                        
                        peaks.push(i);
                        lastPeakIndex = i;
                    }
                }
                
                this.debugLog(`Peak Detection: Found ${peaks.length} peaks, threshold: ${threshold.toFixed(3)}, signal std: ${signalStd.toFixed(3)}`);
                return peaks;
            }
            
            calculateStandardDeviation(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squaredDiffs = values.map(val => (val - mean) ** 2);
                const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / squaredDiffs.length;
                return Math.sqrt(avgSquaredDiff);
            }
            
            updatePPGDisplay() {
                if (this.signalBuffer.length < 2) return;
                
                this.ppgCtx.clearRect(0, 0, this.ppgCanvas.width, this.ppgCanvas.height);
                this.drawPPGGrid();
                
                const displaySamples = Math.min(this.signalBuffer.length, 150);
                const signal = this.signalBuffer.slice(-displaySamples);
                
                if (signal.length > 1) {
                    const min = Math.min(...signal);
                    const max = Math.max(...signal);
                    const range = max - min || 1;
                    
                    this.ppgCtx.beginPath();
                    this.ppgCtx.strokeStyle = '#00ff00';
                    this.ppgCtx.lineWidth = 2;
                    
                    for (let i = 0; i < signal.length; i++) {
                        const x = (i / (signal.length - 1)) * this.ppgCanvas.width;
                        const y = this.ppgCanvas.height - ((signal[i] - min) / range) * (this.ppgCanvas.height - 40) - 20;
                        
                        if (i === 0) {
                            this.ppgCtx.moveTo(x, y);
                        } else {
                            this.ppgCtx.lineTo(x, y);
                        }
                    }
                    
                    this.ppgCtx.stroke();
                }
            }
            
            drawPPGGrid() {
                this.ppgCtx.strokeStyle = '#333';
                this.ppgCtx.lineWidth = 1;
                
                for (let i = 0; i <= 4; i++) {
                    const y = (i / 4) * this.ppgCanvas.height;
                    this.ppgCtx.beginPath();
                    this.ppgCtx.moveTo(0, y);
                    this.ppgCtx.lineTo(this.ppgCanvas.width, y);
                    this.ppgCtx.stroke();
                }
                
                for (let i = 0; i <= 5; i++) {
                    const x = (i / 5) * this.ppgCanvas.width;
                    this.ppgCtx.beginPath();
                    this.ppgCtx.moveTo(x, 0);
                    this.ppgCtx.lineTo(x, this.ppgCanvas.height);
                    this.ppgCtx.stroke();
                }
            }
            
            // DEBUG: Show actual pixel values to understand the problem
            updateMetrics() {
                this.heartRate = this.calculateHeartRate();
                
                document.getElementById('heartRate').textContent = this.heartRate > 0 ? `${this.heartRate} BPM` : '--';
                document.getElementById('snrValue').textContent = this.snr > 0 ? `${this.snr.toFixed(1)}` : '--';
                
                // SHOW ACTUAL VALUES for debugging
                let debugInfo = '';
                if (this.signalBuffer.length > 0) {
                    const currentDC = this.signalBuffer[this.signalBuffer.length - 1];
                    const recentValues = this.signalBuffer.slice(-10);
                    const recentMax = Math.max(...recentValues);
                    const recentMin = Math.min(...recentValues);
                    
                    debugInfo = `DC: ${currentDC.toFixed(1)} | Range: ${recentMin.toFixed(1)}-${recentMax.toFixed(1)}`;
                    
                    // Show actual signal strength based on current implementation
                    let signalStrength = Math.round((currentDC / 255) * 100);
                    document.getElementById('signalStrength').textContent = `${signalStrength}% (Raw: ${currentDC.toFixed(1)})`;
                } else {
                    document.getElementById('signalStrength').textContent = '--';
                }
                
                document.getElementById('dcComponent').textContent = debugInfo || '--';
                
                // Update quality bar with actual percentage
                const qualityBar = document.getElementById('qualityBar');
                const qualityPercent = Math.round(this.signalQuality * 100);
                qualityBar.style.width = `${qualityPercent}%`;
                
                // Show what the algorithm is actually thinking
                let qualityLabel = 'Poor';
                if (qualityPercent >= 80) qualityLabel = 'Excellent';
                else if (qualityPercent >= 60) qualityLabel = 'Good';
                else if (qualityPercent >= 40) qualityLabel = 'Fair';
                
                if (!this.sqmTimeoutTimer && !this.sqmCountdownTimer && this.isProcessing) {
                    const currentStatus = this.currentCoverageStatus || `${qualityLabel} (${qualityPercent}%)`;
                    document.getElementById('qualityText').textContent = currentStatus;
                }
                
                // Enhanced debug output showing actual values vs thresholds
                if (this.signalBuffer.length > 0) {
                    const currentDC = this.signalBuffer[this.signalBuffer.length - 1];
                    this.debugLog(`ACTUAL VALUES: DC=${currentDC.toFixed(1)}, Quality=${qualityPercent}%, Status="${this.currentCoverageStatus}"`);
                    
                    // Show threshold analysis with CORRECTED logic
                    let thresholdAnalysis = '';
                    if (currentDC >= 0.1 && currentDC <= 5) thresholdAnalysis = 'Range 0.1-5 (Excellent)';
                    else if (currentDC > 5 && currentDC <= 15) thresholdAnalysis = 'Range 5-15 (Good)';
                    else if (currentDC > 15 && currentDC <= 40) thresholdAnalysis = 'Range 15-40 (Fair)';
                    else if (currentDC > 40 && currentDC <= 100) thresholdAnalysis = 'Range 40-100 (Poor)';
                    else thresholdAnalysis = 'Above 100 (Uncovered)';
                    
                    this.debugLog(`THRESHOLD CHECK: ${thresholdAnalysis}`);
                }
            }
            
            updateROIDisplay() {
                const cameraView = document.querySelector('.camera-view');
                const rect = cameraView.getBoundingClientRect();
                
                const x = (this.roiParams.x / 100) * rect.width;
                const y = (this.roiParams.y / 100) * rect.height;
                const width = (this.roiParams.width / 100) * rect.width;
                const height = (this.roiParams.height / 100) * rect.height;
                
                if (this.roiType === 'rectangle') {
                    const roiRect = document.getElementById('roiRectangle');
                    roiRect.style.left = `${x}px`;
                    roiRect.style.top = `${y}px`;
                    roiRect.style.width = `${width}px`;
                    roiRect.style.height = `${height}px`;
                    roiRect.style.display = 'block';
                    document.getElementById('roiCircle').style.display = 'none';
                } else {
                    const roiCircle = document.getElementById('roiCircle');
                    const size = Math.min(width, height);
                    roiCircle.style.left = `${x + (width - size) / 2}px`;
                    roiCircle.style.top = `${y + (height - size) / 2}px`;
                    roiCircle.style.width = `${size}px`;
                    roiCircle.style.height = `${size}px`;
                    roiCircle.style.display = 'block';
                    document.getElementById('roiRectangle').style.display = 'none';
                }
            }
            
            checkRecordingReadiness() {
                if (!this.isCameraActive || !this.isProcessing) return;
                
                const isQualityGood = this.signalQuality >= this.qualityThreshold;
                const hasHeartRate = this.heartRate > 0;
                const isReady = isQualityGood && hasHeartRate;
                const timeoutReached = !this.sqmTimeoutTimer;
                
                if (isReady && this.sqmTimeoutTimer) {
                    clearTimeout(this.sqmTimeoutTimer);
                    clearInterval(this.sqmCountdownTimer);
                    this.sqmTimeoutTimer = null;
                    this.sqmCountdownTimer = null;
                    
                    this.updateStatus('Excellent signal quality achieved early! Ready to record.', 'success');
                    document.getElementById('qualityText').textContent = `Excellent quality (${Math.round(this.signalQuality * 100)}%) - ready!`;
                    
                    document.getElementById('startRecordingBtn').disabled = false;
                    document.getElementById('startRecordingBtn').textContent = 'Start Recording';
                    document.getElementById('startRecordingBtn').style.background = '#2563eb';
                    document.getElementById('startRecordingBtn').style.color = 'white';
                }
                
                if (this.sqmTimeoutTimer && this.signalBuffer.length > 0) {
                    const elapsed = Date.now() - this.sqmStartTime;
                    const remaining = Math.max(0, Math.ceil((this.sqmTimeoutDuration - elapsed) / 1000));
                    const currentDC = this.signalBuffer[this.signalBuffer.length - 1];
                    
                    if (currentDC < 5) {
                        this.updateStatus(`Very weak signal (${currentDC.toFixed(1)}) - check flash and finger placement. ${remaining}s remaining.`, 'warning');
                    } else if (currentDC >= 5 && currentDC < 40) {
                        this.updateStatus(`Improving signal (${currentDC.toFixed(1)}) - maintain finger position. ${remaining}s remaining.`, 'info');
                    } else if (currentDC >= 40) {
                        if (!hasHeartRate) {
                            this.updateStatus(`Good signal! Detecting heartbeat... ${remaining}s remaining.`, 'info');
                        } else {
                            this.updateStatus(`Excellent signal with heartbeat! Optimizing quality... ${remaining}s remaining.`, 'info');
                        }
                    }
                }
            }
            
            setRoiType(type) {
                this.roiType = type;
                document.querySelectorAll('.roi-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Roi').classList.add('active');
                // FIXED: Always update ROI display when type changes
                this.updateROIDisplay();
                this.debugLog(`ROI type changed to: ${type}`);
            }
            
            updateSlider(sliderId, value) {
                const valueSpan = document.getElementById(sliderId + 'Value');
                
                if (sliderId === 'recordingDuration') {
                    valueSpan.textContent = `${value}s`;
                } else {
                    valueSpan.textContent = `${value}%`;
                    this.roiParams[sliderId.replace('roi', '').toLowerCase()] = parseInt(value);
                    // FIXED: Always update ROI display when parameters change
                    this.updateROIDisplay();
                }
            }
            
            async calibrateZLO() {
                if (!this.stream || !this.video.srcObject) {
                    this.updateStatus('Please start camera first before calibration', 'error');
                    return;
                }
                
                if (this.isCalibrating) return;
                
                this.isCalibrating = true;
                this.updateStatus('Calibrating Zero Light Offset - Cover camera completely. You should see the feed go dark.', 'info');
                
                document.getElementById('calibrateBtn').disabled = true;
                document.getElementById('calibrateBtn').textContent = 'Calibrating...';
                
                let flashWasEnabled = document.getElementById('flashIndicator').classList.contains('active');
                try {
                    const track = this.stream.getVideoTracks()[0];
                    await track.applyConstraints({
                        advanced: [{ torch: false }]
                    });
                    document.getElementById('flashIndicator').classList.remove('active');
                } catch (error) {
                    this.debugLog(`Flash disable error: ${error.message}`);
                }
                
                this.updateStatus('Cover camera completely with finger. Starting in 3...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.updateStatus('Cover camera completely with finger. Starting in 2...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.updateStatus('Cover camera completely with finger. Starting in 1...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                this.updateStatus('Calibrating... Keep camera covered!', 'info');
                
                const darkSamples = [];
                const sampleCount = 30;
                
                for (let i = 0; i < sampleCount; i++) {
                    const roiData = this.extractROI();
                    const signal = this.calculatePPGSignal(roiData);
                    darkSamples.push(signal);
                    
                    const progress = Math.round(((i + 1) / sampleCount) * 100);
                    this.updateStatus(`Calibrating... ${progress}% complete. Keep camera covered!`, 'info');
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                this.zlo.red = darkSamples.reduce((sum, s) => sum + s.red, 0) / darkSamples.length;
                this.zlo.green = darkSamples.reduce((sum, s) => sum + s.green, 0) / darkSamples.length;
                this.zlo.blue = darkSamples.reduce((sum, s) => sum + s.blue, 0) / darkSamples.length;
                
                if (flashWasEnabled) {
                    try {
                        const track = this.stream.getVideoTracks()[0];
                        await track.applyConstraints({
                            advanced: [{ torch: true }]
                        });
                        document.getElementById('flashIndicator').classList.add('active');
                    } catch (error) {
                        this.debugLog(`Flash re-enable error: ${error.message}`);
                    }
                }
                
                document.getElementById('calibrateBtn').disabled = false;
                document.getElementById('calibrateBtn').textContent = 'Calibrate ZLO';
                
                this.debugLog(`ZLO calibration complete - R: ${this.zlo.red.toFixed(2)}, G: ${this.zlo.green.toFixed(2)}, B: ${this.zlo.blue.toFixed(2)}`);
                this.updateStatus('Calibration complete! Remove finger and position normally for PPG measurement.', 'success');
                
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.signalQuality = 0;
                
                this.isCalibrating = false;
            }
            
            // FIXED: Recording with guaranteed auto-stop
            startRecording() {
                const timeoutReached = !this.sqmTimeoutTimer;
                const isQualityGood = this.signalQuality >= this.qualityThreshold;
                
                if (!timeoutReached && !isQualityGood) {
                    this.updateStatus('Please wait for signal quality improvement or 30-second timeout', 'warning');
                    return;
                }
                
                this.isRecording = true;
                this.recordingData = [];
                this.recordingStartTime = Date.now();
                
                const duration = parseInt(document.getElementById('recordingDuration').value) * 1000;
                
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('recordingIndicator').classList.add('active');
                
                const qualityNote = isQualityGood ? 'good quality' : 'current quality';
                this.updateStatus(`Recording ${duration/1000}s with ${qualityNote}. Quality: ${Math.round(this.signalQuality * 100)}%`, 'info');
                
                // FIXED: Clear any existing timers first
                if (this.recordingTimer) {
                    clearTimeout(this.recordingTimer);
                    this.recordingTimer = null;
                }
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
                
                // Set guaranteed auto-stop timer
                this.recordingTimer = setTimeout(() => {
                    this.debugLog(`AUTO-STOP: Recording timer fired after ${duration}ms`);
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                }, duration);
                
                // Progress bar update with auto-clear
                this.progressInterval = setInterval(() => {
                    if (!this.isRecording) {
                        clearInterval(this.progressInterval);
                        this.progressInterval = null;
                        return;
                    }
                    
                    const elapsed = Date.now() - this.recordingStartTime;
                    const progress = Math.min((elapsed / duration) * 100, 100);
                    document.getElementById('progressFill').style.width = `${progress}%`;
                    
                    // Force stop if duration exceeded (backup safety)
                    if (elapsed >= duration && this.isRecording) {
                        this.debugLog(`BACKUP STOP: Progress timer detected duration exceeded`);
                        clearInterval(this.progressInterval);
                        this.progressInterval = null;
                        this.stopRecording();
                    }
                }, 100);
                
                this.debugLog(`Recording started - Duration: ${duration}ms, Quality: ${(this.signalQuality*100).toFixed(1)}%, Timer ID: ${this.recordingTimer}`);
            }
            
            stopRecording() {
                if (!this.isRecording) return;
                
                this.debugLog('STOP RECORDING: Function called');
                
                // FIXED: Force stop recording first
                this.isRecording = false;
                
                // Clear all timers
                if (this.recordingTimer) {
                    clearTimeout(this.recordingTimer);
                    this.recordingTimer = null;
                }
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
                
                // Update UI
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('progressFill').style.width = '0%';
                
                this.processRecordingResults();
                this.updateStatus(`Recording completed - ${this.recordingData.length} samples collected`, 'success');
                
                this.debugLog(`STOP RECORDING: Completed - ${this.recordingData.length} samples, isRecording: ${this.isRecording}`);
            }
            
            processRecordingResults() {
                if (this.recordingData.length === 0) return;
                
                const avgQuality = this.recordingData.reduce((sum, sample) => sum + sample.quality, 0) / this.recordingData.length;
                const duration = (this.recordingData[this.recordingData.length - 1].timestamp - this.recordingData[0].timestamp) / 1000;
                const sampleRate = this.recordingData.length / duration;
                
                const results = {
                    metadata: {
                        deviceType: this.deviceType,
                        roiType: this.roiType,
                        roiParams: { ...this.roiParams },
                        zloCalibration: { ...this.zlo },
                        recordingDuration: duration,
                        sampleCount: this.recordingData.length,
                        sampleRate: sampleRate.toFixed(2),
                        averageQuality: (avgQuality * 100).toFixed(1),
                        heartRate: this.heartRate,
                        snr: this.snr.toFixed(2),
                        timestamp: new Date().toISOString()
                    },
                    ppgSignal: this.recordingData.map((sample, index) => ({
                        sampleIndex: index,
                        timeMs: sample.timestamp - this.recordingData[0].timestamp,
                        ppgValue: parseFloat(sample.ppgValue.toFixed(3)),
                        qualityScore: parseFloat(sample.quality.toFixed(3))
                    }))
                };
                
                this.recordingResults = results;
                this.displayResults();
            }
            
            displayResults() {
                const resultsSection = document.getElementById('downloadSection');
                const resultsPreview = document.getElementById('resultsPreview');
                
                const metadata = this.recordingResults.metadata;
                const preview = `Recording Summary:
Device Type: ${metadata.deviceType}
ROI Type: ${metadata.roiType}
Duration: ${metadata.recordingDuration.toFixed(1)}s
Sample Count: ${metadata.sampleCount}
Sample Rate: ${metadata.sampleRate} Hz
Average Quality: ${metadata.averageQuality}%
Heart Rate: ${metadata.heartRate} BPM
SNR: ${metadata.snr} dB

ZLO Calibration:
Red: ${metadata.zloCalibration.red.toFixed(2)}
Green: ${metadata.zloCalibration.green.toFixed(2)}
Blue: ${metadata.zloCalibration.blue.toFixed(2)}

Data preview (first 5 samples):
${this.recordingResults.ppgSignal.slice(0, 5).map(sample => 
    `Sample ${sample.sampleIndex}: Time=${sample.timeMs}ms, PPG=${sample.ppgValue}, Quality=${sample.qualityScore}`
).join('\n')}`;
                
                resultsPreview.textContent = preview;
                resultsSection.style.display = 'block';
            }
            
            downloadResults() {
                if (!this.recordingResults) return;
                
                const jsonData = JSON.stringify(this.recordingResults, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `ppg_recording_${this.deviceType}_${timestamp}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.debugLog(`Downloaded results: ${filename}`);
            }
            
            resetSystem() {
                this.debugLog('System reset initiated');
                
                this.isRecording = false;
                this.isCalibrating = false;
                this.isCameraActive = false;
                this.isProcessing = false;
                
                if (this.recordingTimer) clearTimeout(this.recordingTimer);
                if (this.progressInterval) clearInterval(this.progressInterval);
                if (this.sqmTimeoutTimer) {
                    clearTimeout(this.sqmTimeoutTimer);
                    this.sqmTimeoutTimer = null;
                }
                if (this.sqmCountdownTimer) {
                    clearInterval(this.sqmCountdownTimer);
                    this.sqmCountdownTimer = null;
                }
                
                this.sqmStartTime = null;
                this.recordingStartTime = null;
                
                this.recordingData = [];
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.signalQuality = 0;
                this.heartRate = 0;
                this.snr = 0;
                
                this.zlo = { red: 0, green: 0, blue: 0 };
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    this.video.srcObject = null;
                }
                
                document.getElementById('startCameraBtn').disabled = false;
                document.getElementById('startCameraBtn').textContent = 'Start Camera';
                document.getElementById('startSQMBtn').disabled = true;
                document.getElementById('startSQMBtn').textContent = 'Start Signal Monitor';
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('startRecordingBtn').textContent = 'Start Recording';
                document.getElementById('startRecordingBtn').style.background = '#2563eb';
                document.getElementById('startRecordingBtn').style.color = 'white';
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('calibrateBtn').disabled = true;
                document.getElementById('calibrateBtn').textContent = 'Calibrate ZLO';
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('flashIndicator').classList.remove('active');
                document.getElementById('downloadSection').style.display = 'none';
                
                document.getElementById('qualityBar').style.width = '0%';
                document.getElementById('qualityText').textContent = 'Android selected - click Start Camera';
                
                document.getElementById('heartRate').textContent = '--';
                document.getElementById('snrValue').textContent = '--';
                document.getElementById('signalStrength').textContent = '--';
                document.getElementById('dcComponent').textContent = '--';
                
                this.ppgCtx.clearRect(0, 0, this.ppgCanvas.width, this.ppgCanvas.height);
                this.drawPPGGrid();
                
                // FIXED: Reset to Android default
                document.querySelectorAll('.device-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('androidBtn').classList.add('active');
                this.deviceType = 'android';
                
                this.updateStatus('System reset complete. Android selected by default.', 'info');
                
                this.debugLog('System reset completed successfully');
            }
            
            updateStatus(message, type) {
                const statusElement = document.getElementById('statusMessage');
                statusElement.textContent = message;
                statusElement.className = `status-message status-${type}`;
                
                this.debugLog(`Status (${type}): ${message}`);
            }
            
            startDebugLog() {
                this.debugMessages = [];
                this.debugLog('PPG Recorder initialized with CORRECTED signal quality logic');
                this.debugLog('LOW DC values (finger covering camera) = EXCELLENT quality');
                this.debugLog('HIGH DC values (environmental light) = POOR quality');
            }
            
            debugLog(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                this.debugMessages = this.debugMessages || [];
                this.debugMessages.push(logEntry);
                
                if (this.debugMessages.length > 100) {
                    this.debugMessages.shift();
                }
                
                const debugContent = document.getElementById('debugContent');
                debugContent.textContent = this.debugMessages.join('\n');
                debugContent.scrollTop = debugContent.scrollHeight;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            window.ppgRecorder = new PPGRecorder();
        });
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript,console.log("SW registered")');
        }
    </script>
</body>
</html>