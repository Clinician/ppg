<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPG Signal Recorder</title>
    <meta name="theme-color" content="#2563eb">
    <link rel="manifest" href="data:application/json,{
        'name': 'PPG Signal Recorder',
        'short_name': 'PPG Recorder',
        'description': 'Professional smartphone-based photoplethysmography signal recording',
        'start_url': '/',
        'display': 'standalone',
        'background_color': '#ffffff',
        'theme_color': '#2563eb',
        'icons': [
            {
                'src': 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%232563eb%22 width=%22100%22 height=%22100%22/><path fill=%22white%22 d=%22M20 50 L35 35 L50 50 L65 35 L80 50 L65 65 L50 50 L35 65 Z%22/></svg>',
                'sizes': '192x192',
                'type': 'image/svg+xml'
            }
        ]
    }">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }
        
        .device-setup {
            text-align: center;
        }
        
        .device-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .device-btn {
            padding: 15px 30px;
            border: 2px solid #2563eb;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .device-btn.active {
            background: #2563eb;
            color: white;
        }
        
        .device-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .camera-container {
            position: relative;
            margin: 20px 0;
        }
        
        .camera-view {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .roi-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .roi-rectangle {
            position: absolute;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .roi-circle {
            position: absolute;
            border: 3px solid #00ff00;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }
        
        .roi-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .roi-btn {
            padding: 10px 20px;
            border: 2px solid #2563eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .roi-btn.active {
            background: #2563eb;
            color: white;
        }
        
        .signal-quality {
            text-align: center;
        }
        
        .quality-meter {
            width: 200px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            margin: 15px auto;
            overflow: hidden;
            position: relative;
        }
        
        .quality-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa44 50%, #44ff44 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .quality-text {
            margin-top: 10px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .ppg-display {
            margin-top: 20px;
        }
        
        .ppg-canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 10px;
            border: 2px solid #333;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #2563eb;
        }
        
        .recording-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #2563eb;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-danger {
            background: #dc2626;
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .recording-indicator {
            display: none;
            text-align: center;
            color: #dc2626;
            font-weight: bold;
            font-size: 1.2rem;
            margin: 10px 0;
        }
        
        .recording-indicator.active {
            display: block;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #2563eb;
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .debug-panel {
            margin-top: 20px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .debug-header {
            padding: 15px;
            background: #e9ecef;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-content {
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            display: none;
        }
        
        .debug-content.open {
            display: block;
        }
        
        .flash-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fbbf24;
            border: 2px solid #f59e0b;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .flash-indicator.active {
            opacity: 1;
            box-shadow: 0 0 20px #fbbf24;
        }
        
        .status-message {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .status-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #f59e0b;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        
        .download-section {
            margin-top: 20px;
            text-align: center;
        }
        
        .results-preview {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì± PPG Signal Recorder</h1>
            <p>Professional smartphone-based photoplethysmography recording</p>
        </div>
        
        <div class="main-grid">
            <div class="card">
                <div class="device-setup">
                    <h3>üì± Device Configuration</h3>
                    <div class="device-buttons">
                        <button class="device-btn" id="androidBtn">Android</button>
                        <button class="device-btn" id="iosBtn">iOS</button>
                    </div>
                    
                    <div class="camera-container">
                        <div class="camera-view">
                            <video id="cameraFeed" autoplay muted playsinline></video>
                            <canvas id="processingCanvas" style="display: none;"></canvas>
                            <div class="roi-overlay">
                                <div id="roiRectangle" class="roi-rectangle"></div>
                                <div id="roiCircle" class="roi-circle" style="display: none;"></div>
                            </div>
                            <div class="flash-indicator" id="flashIndicator"></div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>ROI Type:</label>
                            <div class="roi-type-selector">
                                <button class="roi-btn active" id="rectangleRoi">Rectangle</button>
                                <button class="roi-btn" id="circularRoi">Circular</button>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI X Position:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiX" min="10" max="90" value="25">
                                <span class="slider-value" id="roiXValue">25%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Y Position:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiY" min="10" max="90" value="25">
                                <span class="slider-value" id="roiYValue">25%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Width:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiWidth" min="20" max="80" value="50">
                                <span class="slider-value" id="roiWidthValue">50%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>ROI Height:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="roiHeight" min="20" max="80" value="50">
                                <span class="slider-value" id="roiHeightValue">50%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Recording Duration:</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="recordingDuration" min="5" max="30" value="10" step="5">
                                <span class="slider-value" id="recordingDurationValue">10s</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="signal-quality">
                    <h3>üìä Signal Quality Monitor</h3>
                    
                    <div class="quality-meter">
                        <div class="quality-bar" id="qualityBar"></div>
                    </div>
                    <div class="quality-text" id="qualityText">Initializing...</div>
                    
                    <div class="status-message status-info" id="statusMessage">
                        Position your fingertip over the rear camera and flash
                    </div>
                    
                    <div class="ppg-display">
                        <canvas class="ppg-canvas" id="ppgCanvas"></canvas>
                        
                        <div class="metrics">
                            <div class="metric">
                                <div class="metric-label">Heart Rate</div>
                                <div class="metric-value" id="heartRate">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">SNR (dB)</div>
                                <div class="metric-value" id="snrValue">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Signal Strength</div>
                                <div class="metric-value" id="signalStrength">--</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">DC Component</div>
                                <div class="metric-value" id="dcComponent">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="recording-controls">
                <button class="btn btn-secondary" id="startCameraBtn">üì∑ Start Camera</button>
                <button class="btn btn-primary" id="startRecordingBtn" disabled>üî¥ Start Recording</button>
                <button class="btn btn-danger" id="stopRecordingBtn" disabled>‚èπÔ∏è Stop</button>
                <button class="btn btn-secondary" id="calibrateBtn">‚öôÔ∏è Calibrate ZLO</button>
                <button class="btn btn-secondary" id="resetBtn">üîÑ Reset</button>
            </div>
            
            <div class="recording-indicator" id="recordingIndicator">
                üî¥ RECORDING IN PROGRESS...
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="card download-section" id="downloadSection" style="display: none;">
            <h3>üì• Recording Results</h3>
            <div class="results-preview" id="resultsPreview"></div>
            <button class="btn btn-primary" id="downloadBtn">üíæ Download PPG Data</button>
        </div>
        
        <div class="card">
            <div class="debug-panel">
                <div class="debug-header" id="debugHeader">üîß Debug Information (Click to toggle)</div>
                <div class="debug-content" id="debugContent"></div>
            </div>
        </div>
    </div>

    <script>
        class PPGRecorder {
            constructor() {
                this.stream = null;
                this.video = document.getElementById('cameraFeed');
                this.canvas = document.getElementById('processingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ppgCanvas = document.getElementById('ppgCanvas');
                this.ppgCtx = this.ppgCanvas.getContext('2d');
                
                this.isRecording = false;
                this.isCalibrating = false;
                this.recordingData = [];
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.sampleRate = 30; // Target 30fps
                this.bufferSize = 300; // 10 seconds at 30fps
                
                this.deviceType = null;
                this.roiType = 'rectangle';
                this.roiParams = { x: 25, y: 25, width: 50, height: 50 };
                this.zlo = { red: 0, green: 0, blue: 0 }; // Zero Light Offset calibration
                
                this.qualityThreshold = 0.6;
                this.signalQuality = 0;
                this.heartRate = 0;
                this.snr = 0;
                
                this.initializeEventListeners();
                this.initializeCanvases();
                this.startDebugLog();
            }
            
            initializeEventListeners() {
                // Device selection
                document.getElementById('androidBtn').addEventListener('click', () => this.selectDevice('android'));
                document.getElementById('iosBtn').addEventListener('click', () => this.selectDevice('ios'));
                
                // Camera controls
                document.getElementById('startCameraBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('startRecordingBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecordingBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrateZLO());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSystem());
                
                // ROI controls
                document.getElementById('rectangleRoi').addEventListener('click', () => this.setRoiType('rectangle'));
                document.getElementById('circularRoi').addEventListener('click', () => this.setRoiType('circular'));
                
                // Sliders
                const sliders = ['roiX', 'roiY', 'roiWidth', 'roiHeight', 'recordingDuration'];
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    slider.addEventListener('input', (e) => this.updateSlider(id, e.target.value));
                });
                
                // Debug panel toggle
                document.getElementById('debugHeader').addEventListener('click', () => {
                    const content = document.getElementById('debugContent');
                    content.classList.toggle('open');
                });
                
                // Download button
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadResults());
            }
            
            initializeCanvases() {
                this.ppgCanvas.width = this.ppgCanvas.offsetWidth;
                this.ppgCanvas.height = this.ppgCanvas.offsetHeight;
                this.drawPPGGrid();
            }
            
            selectDevice(type) {
                this.deviceType = type;
                document.querySelectorAll('.device-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Btn').classList.add('active');
                
                this.debugLog(`Selected device type: ${type}`);
                
                if (type === 'ios') {
                    this.updateStatus('iOS detected: Limited camera control available', 'warning');
                } else {
                    this.updateStatus('Android selected: Full camera control available', 'info');
                }
            }
            
            async startCamera() {
                try {
                    if (!this.deviceType) {
                        this.updateStatus('Please select device type first', 'error');
                        return;
                    }
                    
                    this.updateStatus('Requesting camera access...', 'info');
                    
                    const constraints = this.getCameraConstraints();
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    this.video.addEventListener('loadedmetadata', () => {
                        this.setupProcessing();
                        this.updateStatus('Camera started. Position finger over rear camera with flash.', 'success');
                        document.getElementById('startCameraBtn').disabled = true;
                    });
                    
                } catch (error) {
                    this.debugLog(`Camera error: ${error.message}`);
                    this.updateStatus('Camera access denied or unavailable', 'error');
                }
            }
            
            getCameraConstraints() {
                const baseConstraints = {
                    video: {
                        facingMode: { exact: 'environment' }, // Rear camera
                        width: { ideal: 1920, min: 640 },
                        height: { ideal: 1080, min: 480 },
                        frameRate: { ideal: 30, min: 15 }
                    }
                };
                
                if (this.deviceType === 'android') {
                    // Android-specific optimizations based on the research paper
                    baseConstraints.video.exposureMode = 'manual';
                    baseConstraints.video.whiteBalanceMode = 'manual';
                    baseConstraints.video.colorTemperature = 3000; // Incandescent setting
                } else if (this.deviceType === 'ios') {
                    // iOS optimizations (limited due to API constraints)
                    baseConstraints.video.exposureMode = 'continuous';
                    baseConstraints.video.focusMode = 'continuous';
                }
                
                return baseConstraints;
            }
            
            setupProcessing() {
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                
                // Enable flash if available
                this.enableFlash();
                
                // Start processing loop
                this.processingLoop();
            }
            
            async enableFlash() {
                try {
                    const track = this.stream.getVideoTracks()[0];
                    const capabilities = track.getCapabilities();
                    
                    if (capabilities.torch) {
                        await track.applyConstraints({
                            advanced: [{ torch: true }]
                        });
                        document.getElementById('flashIndicator').classList.add('active');
                        this.debugLog('Flash enabled successfully');
                    } else {
                        this.debugLog('Flash not supported on this device');
                        this.updateStatus('Flash not available - results may be less accurate', 'warning');
                    }
                } catch (error) {
                    this.debugLog(`Flash error: ${error.message}`);
                }
            }
            
            
            resetSystem() {
                this.debugLog('System reset initiated');
                
                // Stop any ongoing processes
                this.isRecording = false;
                this.isCalibrating = false;
                
                // Clear timers
                if (this.recordingTimer) clearTimeout(this.recordingTimer);
                if (this.progressInterval) clearInterval(this.progressInterval);
                
                // Clear buffers and data
                this.recordingData = [];
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.signalQuality = 0;
                this.heartRate = 0;
                this.snr = 0;
                
                // Reset ZLO calibration
                this.zlo = { red: 0, green: 0, blue: 0 };
                
                // Stop camera if running
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    this.video.srcObject = null;
                }
                
                // Reset UI elements
                document.getElementById('startCameraBtn').disabled = false;
                document.getElementById('startCameraBtn').textContent = 'üì∑ Start Camera';
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('calibrateBtn').disabled = false;
                document.getElementById('calibrateBtn').textContent = '‚öôÔ∏è Calibrate ZLO';
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('flashIndicator').classList.remove('active');
                document.getElementById('downloadSection').style.display = 'none';
                
                // Reset quality display
                document.getElementById('qualityBar').style.width = '0%';
                document.getElementById('qualityText').textContent = 'System Reset';
                
                // Reset metrics
                document.getElementById('heartRate').textContent = '--';
                document.getElementById('snrValue').textContent = '--';
                document.getElementById('signalStrength').textContent = '--';
                document.getElementById('dcComponent').textContent = '--';
                
                // Clear PPG canvas
                this.ppgCtx.clearRect(0, 0, this.ppgCanvas.width, this.ppgCanvas.height);
                this.drawPPGGrid();
                
                // Reset device selection
                document.querySelectorAll('.device-btn').forEach(btn => btn.classList.remove('active'));
                this.deviceType = null;
                
                this.updateStatus('System reset complete. Please select device type and start camera.', 'info');
                
                this.debugLog('System reset completed successfully');
            }
            
            processingLoop() {
                if (!this.video.paused && !this.video.ended && this.stream) {
                    this.processFrame();
                    requestAnimationFrame(() => this.processingLoop());
                }
            }
            
            processFrame() {
                // Skip processing during calibration to avoid interference
                if (this.isCalibrating) {
                    requestAnimationFrame(() => this.processingLoop());
                    return;
                }
                
                // Draw video frame to canvas
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                
                // Extract ROI
                const roiData = this.extractROI();
                
                // Calculate PPG signal
                const signal = this.calculatePPGSignal(roiData);
                
                // Apply ZLO correction
                const correctedSignal = this.applyZLOCorrection(signal);
                
                // Update signal buffer
                this.updateSignalBuffer(correctedSignal);
                
                // Assess signal quality
                this.assessSignalQuality();
                
                // Update displays
                this.updatePPGDisplay();
                this.updateMetrics();
                this.updateROIDisplay();
                
                // Check recording readiness
                this.checkRecordingReadiness();
            }
            
            extractROI() {
                const x = Math.floor((this.roiParams.x / 100) * this.canvas.width);
                const y = Math.floor((this.roiParams.y / 100) * this.canvas.height);
                const width = Math.floor((this.roiParams.width / 100) * this.canvas.width);
                const height = Math.floor((this.roiParams.height / 100) * this.canvas.height);
                
                if (this.roiType === 'rectangle') {
                    return this.ctx.getImageData(x, y, width, height);
                } else {
                    // Circular ROI
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;
                    const radius = Math.min(width, height) / 2;
                    
                    const imageData = this.ctx.getImageData(x, y, width, height);
                    const circularData = new ImageData(width, height);
                    
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const pixelX = (i / 4) % width;
                        const pixelY = Math.floor((i / 4) / width);
                        const distance = Math.sqrt((pixelX - width/2) ** 2 + (pixelY - height/2) ** 2);
                        
                        if (distance <= radius) {
                            circularData.data[i] = imageData.data[i];
                            circularData.data[i + 1] = imageData.data[i + 1];
                            circularData.data[i + 2] = imageData.data[i + 2];
                            circularData.data[i + 3] = imageData.data[i + 3];
                        }
                    }
                    
                    return circularData;
                }
            }
            
            calculatePPGSignal(imageData) {
                const data = imageData.data;
                let redSum = 0, greenSum = 0, blueSum = 0;
                let pixelCount = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // Check alpha channel for valid pixels
                        redSum += data[i];
                        greenSum += data[i + 1];
                        blueSum += data[i + 2];
                        pixelCount++;
                    }
                }
                
                if (pixelCount === 0) return { red: 0, green: 0, blue: 0 };
                
                return {
                    red: redSum / pixelCount,
                    green: greenSum / pixelCount,
                    blue: blueSum / pixelCount
                };
            }
            
            applyZLOCorrection(signal) {
                return {
                    red: Math.max(0, signal.red - this.zlo.red),
                    green: Math.max(0, signal.green - this.zlo.green),
                    blue: Math.max(0, signal.blue - this.zlo.blue)
                };
            }
            
            updateSignalBuffer(signal) {
                const timestamp = performance.now();
                
                // Use green channel for PPG (best for heart rate detection)
                this.signalBuffer.push(signal.green);
                this.timeBuffer.push(timestamp);
                
                // Maintain buffer size
                if (this.signalBuffer.length > this.bufferSize) {
                    this.signalBuffer.shift();
                    this.timeBuffer.shift();
                }
                
                // Store for recording if active
                if (this.isRecording) {
                    this.recordingData.push({
                        timestamp: timestamp,
                        red: signal.red,
                        green: signal.green,
                        blue: signal.blue,
                        quality: this.signalQuality
                    });
                }
            }
            
            assessSignalQuality() {
                if (this.signalBuffer.length < 60) { // Need at least 2 seconds of data
                    this.signalQuality = 0;
                    return;
                }
                
                // Calculate signal-to-noise ratio
                const signal = this.signalBuffer.slice(-60); // Last 2 seconds
                const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
                const variance = signal.reduce((sum, val) => sum + (val - mean) ** 2, 0) / signal.length;
                const std = Math.sqrt(variance);
                
                // Calculate AC/DC ratio (important for PPG quality)
                const ac = std;
                const dc = mean;
                const acDcRatio = dc > 0 ? ac / dc : 0;
                
                // SNR calculation
                this.snr = dc > 0 ? 20 * Math.log10(ac / (std * 0.1 + 0.01)) : 0;
                
                // Quality score based on multiple factors
                const dcQuality = Math.min(dc / 100, 1); // DC component strength
                const acQuality = Math.min(acDcRatio * 100, 1); // AC/DC ratio
                const snrQuality = Math.min(Math.max(this.snr / 20, 0), 1); // SNR quality
                const stabilityQuality = this.calculateStabilityQuality();
                
                this.signalQuality = (dcQuality + acQuality + snrQuality + stabilityQuality) / 4;
                
                this.debugLog(`Quality Assessment - DC: ${dc.toFixed(2)}, AC/DC: ${acDcRatio.toFixed(4)}, SNR: ${this.snr.toFixed(2)}dB, Overall: ${(this.signalQuality * 100).toFixed(1)}%`);
            }
            
            calculateStabilityQuality() {
                if (this.signalBuffer.length < 90) return 0;
                
                const recent = this.signalBuffer.slice(-90, -60); // 3-2 seconds ago
                const current = this.signalBuffer.slice(-60); // Last 2 seconds
                
                const recentMean = recent.reduce((a, b) => a + b, 0) / recent.length;
                const currentMean = current.reduce((a, b) => a + b, 0) / current.length;
                
                const stability = 1 - Math.abs(recentMean - currentMean) / Math.max(recentMean, currentMean, 1);
                return Math.max(0, stability);
            }
            
            calculateHeartRate() {
                if (this.signalBuffer.length < 120) return 0; // Need at least 4 seconds
                
                const signal = this.signalBuffer.slice(-120); // Last 4 seconds
                const sampleRate = 30; // Approximate frame rate
                
                // Simple peak detection for heart rate
                const peaks = this.findPeaks(signal);
                if (peaks.length < 2) return 0;
                
                // Calculate intervals between peaks
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i] - peaks[i-1]);
                }
                
                // Average interval in samples
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                
                // Convert to BPM
                const bpm = (60 * sampleRate) / avgInterval;
                
                // Filter reasonable heart rates (40-180 BPM)
                return (bpm >= 40 && bpm <= 180) ? Math.round(bpm) : 0;
            }
            
            findPeaks(signal) {
                const peaks = [];
                const threshold = this.calculateThreshold(signal);
                
                for (let i = 1; i < signal.length - 1; i++) {
                    if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                        peaks.push(i);
                    }
                }
                
                return peaks;
            }
            
            calculateThreshold(signal) {
                const sorted = [...signal].sort((a, b) => a - b);
                const percentile75 = sorted[Math.floor(sorted.length * 0.75)];
                return percentile75;
            }
            
            updatePPGDisplay() {
                if (this.signalBuffer.length < 2) return;
                
                this.ppgCtx.clearRect(0, 0, this.ppgCanvas.width, this.ppgCanvas.height);
                this.drawPPGGrid();
                
                // Draw signal
                const displaySamples = Math.min(this.signalBuffer.length, 150); // Last 5 seconds at 30fps
                const signal = this.signalBuffer.slice(-displaySamples);
                
                if (signal.length > 1) {
                    // Normalize signal for display
                    const min = Math.min(...signal);
                    const max = Math.max(...signal);
                    const range = max - min || 1;
                    
                    this.ppgCtx.beginPath();
                    this.ppgCtx.strokeStyle = '#00ff00';
                    this.ppgCtx.lineWidth = 2;
                    
                    for (let i = 0; i < signal.length; i++) {
                        const x = (i / (signal.length - 1)) * this.ppgCanvas.width;
                        const y = this.ppgCanvas.height - ((signal[i] - min) / range) * (this.ppgCanvas.height - 40) - 20;
                        
                        if (i === 0) {
                            this.ppgCtx.moveTo(x, y);
                        } else {
                            this.ppgCtx.lineTo(x, y);
                        }
                    }
                    
                    this.ppgCtx.stroke();
                }
            }
            
            drawPPGGrid() {
                this.ppgCtx.strokeStyle = '#333';
                this.ppgCtx.lineWidth = 1;
                
                // Horizontal lines
                for (let i = 0; i <= 4; i++) {
                    const y = (i / 4) * this.ppgCanvas.height;
                    this.ppgCtx.beginPath();
                    this.ppgCtx.moveTo(0, y);
                    this.ppgCtx.lineTo(this.ppgCanvas.width, y);
                    this.ppgCtx.stroke();
                }
                
                // Vertical lines
                for (let i = 0; i <= 5; i++) {
                    const x = (i / 5) * this.ppgCanvas.width;
                    this.ppgCtx.beginPath();
                    this.ppgCtx.moveTo(x, 0);
                    this.ppgCtx.lineTo(x, this.ppgCanvas.height);
                    this.ppgCtx.stroke();
                }
            }
            
            updateMetrics() {
                this.heartRate = this.calculateHeartRate();
                
                document.getElementById('heartRate').textContent = this.heartRate > 0 ? `${this.heartRate} BPM` : '--';
                document.getElementById('snrValue').textContent = this.snr > 0 ? `${this.snr.toFixed(1)}` : '--';
                
                const signalStrength = this.signalBuffer.length > 0 ? 
                    Math.round((this.signalBuffer[this.signalBuffer.length - 1] / 255) * 100) : 0;
                document.getElementById('signalStrength').textContent = `${signalStrength}%`;
                
                const dcComponent = this.signalBuffer.length > 0 ? 
                    this.signalBuffer[this.signalBuffer.length - 1].toFixed(1) : '--';
                document.getElementById('dcComponent').textContent = dcComponent;
                
                // Update quality bar
                const qualityBar = document.getElementById('qualityBar');
                const qualityText = document.getElementById('qualityText');
                const qualityPercent = Math.round(this.signalQuality * 100);
                
                qualityBar.style.width = `${qualityPercent}%`;
                
                let qualityLabel = 'Poor';
                if (qualityPercent > 80) qualityLabel = 'Excellent';
                else if (qualityPercent > 60) qualityLabel = 'Good';
                else if (qualityPercent > 40) qualityLabel = 'Fair';
                
                qualityText.textContent = `${qualityLabel} (${qualityPercent}%)`;
            }
            
            updateROIDisplay() {
                const cameraView = document.querySelector('.camera-view');
                const rect = cameraView.getBoundingClientRect();
                
                const x = (this.roiParams.x / 100) * rect.width;
                const y = (this.roiParams.y / 100) * rect.height;
                const width = (this.roiParams.width / 100) * rect.width;
                const height = (this.roiParams.height / 100) * rect.height;
                
                if (this.roiType === 'rectangle') {
                    const roiRect = document.getElementById('roiRectangle');
                    roiRect.style.left = `${x}px`;
                    roiRect.style.top = `${y}px`;
                    roiRect.style.width = `${width}px`;
                    roiRect.style.height = `${height}px`;
                    roiRect.style.display = 'block';
                    document.getElementById('roiCircle').style.display = 'none';
                } else {
                    const roiCircle = document.getElementById('roiCircle');
                    const size = Math.min(width, height);
                    roiCircle.style.left = `${x + (width - size) / 2}px`;
                    roiCircle.style.top = `${y + (height - size) / 2}px`;
                    roiCircle.style.width = `${size}px`;
                    roiCircle.style.height = `${size}px`;
                    roiCircle.style.display = 'block';
                    document.getElementById('roiRectangle').style.display = 'none';
                }
            }
            
            checkRecordingReadiness() {
                const isReady = this.signalQuality >= this.qualityThreshold && this.heartRate > 0;
                document.getElementById('startRecordingBtn').disabled = !isReady;
                
                if (isReady && !this.isRecording) {
                    this.updateStatus('Signal quality good - Ready to record!', 'success');
                } else if (!isReady && !this.isRecording) {
                    this.updateStatus('Improving signal... Keep finger steady over camera.', 'warning');
                }
            }
            
            setRoiType(type) {
                this.roiType = type;
                document.querySelectorAll('.roi-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Roi').classList.add('active');
                this.debugLog(`ROI type changed to: ${type}`);
            }
            
            updateSlider(sliderId, value) {
                const valueSpan = document.getElementById(sliderId + 'Value');
                
                if (sliderId === 'recordingDuration') {
                    valueSpan.textContent = `${value}s`;
                } else {
                    valueSpan.textContent = `${value}%`;
                    this.roiParams[sliderId.replace('roi', '').toLowerCase()] = parseInt(value);
                }
            }
            
            async calibrateZLO() {
                // Check if camera is started first
                if (!this.stream || !this.video.srcObject) {
                    this.updateStatus('Please start camera first before calibration', 'error');
                    return;
                }
                
                if (this.isCalibrating) return;
                
                this.isCalibrating = true;
                this.updateStatus('Calibrating Zero Light Offset - Cover camera completely. You should see the camera feed go dark.', 'info');
                
                // Keep camera feed visible during calibration so user can see coverage
                document.getElementById('calibrateBtn').disabled = true;
                document.getElementById('calibrateBtn').textContent = '‚öôÔ∏è Calibrating...';
                
                // Disable flash for calibration
                let flashWasEnabled = document.getElementById('flashIndicator').classList.contains('active');
                try {
                    const track = this.stream.getVideoTracks()[0];
                    await track.applyConstraints({
                        advanced: [{ torch: false }]
                    });
                    document.getElementById('flashIndicator').classList.remove('active');
                } catch (error) {
                    this.debugLog(`Flash disable error: ${error.message}`);
                }
                
                // Give user time to see the instruction and cover camera
                this.updateStatus('Cover the camera completely with your finger. Calibration starting in 3 seconds...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.updateStatus('Cover the camera completely with your finger. Calibration starting in 2 seconds...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.updateStatus('Cover the camera completely with your finger. Calibration starting in 1 second...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                this.updateStatus('Calibrating... Keep camera covered!', 'info');
                
                // Collect dark samples
                const darkSamples = [];
                const sampleCount = 30;
                
                for (let i = 0; i < sampleCount; i++) {
                    const roiData = this.extractROI();
                    const signal = this.calculatePPGSignal(roiData);
                    darkSamples.push(signal);
                    
                    // Show progress
                    const progress = Math.round(((i + 1) / sampleCount) * 100);
                    this.updateStatus(`Calibrating... ${progress}% complete. Keep camera covered!`, 'info');
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Calculate ZLO values
                this.zlo.red = darkSamples.reduce((sum, s) => sum + s.red, 0) / darkSamples.length;
                this.zlo.green = darkSamples.reduce((sum, s) => sum + s.green, 0) / darkSamples.length;
                this.zlo.blue = darkSamples.reduce((sum, s) => sum + s.blue, 0) / darkSamples.length;
                
                // Re-enable flash if it was enabled before
                if (flashWasEnabled) {
                    try {
                        const track = this.stream.getVideoTracks()[0];
                        await track.applyConstraints({
                            advanced: [{ torch: true }]
                        });
                        document.getElementById('flashIndicator').classList.add('active');
                    } catch (error) {
                        this.debugLog(`Flash re-enable error: ${error.message}`);
                    }
                }
                
                // Reset button and status
                document.getElementById('calibrateBtn').disabled = false;
                document.getElementById('calibrateBtn').textContent = '‚öôÔ∏è Calibrate ZLO';
                
                this.debugLog(`ZLO Calibration complete - R: ${this.zlo.red.toFixed(2)}, G: ${this.zlo.green.toFixed(2)}, B: ${this.zlo.blue.toFixed(2)}`);
                this.updateStatus('Calibration complete! Remove finger and position normally for PPG measurement.', 'success');
                
                // Clear signal buffer to start fresh after calibration
                this.signalBuffer = [];
                this.timeBuffer = [];
                this.signalQuality = 0;
                
                this.isCalibrating = false;
            }
            
            startRecording() {
                if (this.signalQuality < this.qualityThreshold) {
                    this.updateStatus('Signal quality too low for recording', 'error');
                    return;
                }
                
                this.isRecording = true;
                this.recordingData = [];
                
                const duration = parseInt(document.getElementById('recordingDuration').value) * 1000;
                const startTime = performance.now();
                
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('recordingIndicator').classList.add('active');
                
                this.updateStatus(`Recording for ${duration/1000} seconds...`, 'info');
                
                // Auto-stop recording after specified duration
                this.recordingTimer = setTimeout(() => {
                    this.stopRecording();
                }, duration);
                
                // Update progress bar
                this.progressInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min((elapsed / duration) * 100, 100);
                    document.getElementById('progressFill').style.width = `${progress}%`;
                }, 100);
                
                this.debugLog(`Recording started for ${duration}ms`);
            }
            
            stopRecording() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                clearTimeout(this.recordingTimer);
                clearInterval(this.progressInterval);
                
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('progressFill').style.width = '0%';
                
                this.processRecordingResults();
                this.updateStatus(`Recording completed - ${this.recordingData.length} samples collected`, 'success');
                
                this.debugLog(`Recording stopped - ${this.recordingData.length} samples`);
            }
            
            processRecordingResults() {
                if (this.recordingData.length === 0) return;
                
                // Calculate recording statistics
                const avgQuality = this.recordingData.reduce((sum, sample) => sum + sample.quality, 0) / this.recordingData.length;
                const duration = (this.recordingData[this.recordingData.length - 1].timestamp - this.recordingData[0].timestamp) / 1000;
                const sampleRate = this.recordingData.length / duration;
                
                // Prepare results preview
                const results = {
                    metadata: {
                        deviceType: this.deviceType,
                        roiType: this.roiType,
                        roiParams: { ...this.roiParams },
                        zloCalibration: { ...this.zlo },
                        recordingDuration: duration,
                        sampleCount: this.recordingData.length,
                        sampleRate: sampleRate.toFixed(2),
                        averageQuality: (avgQuality * 100).toFixed(1),
                        heartRate: this.heartRate,
                        snr: this.snr.toFixed(2)
                    },
                    data: this.recordingData.map(sample => ({
                        timestamp: sample.timestamp,
                        red: sample.red.toFixed(2),
                        green: sample.green.toFixed(2),
                        blue: sample.blue.toFixed(2),
                        quality: sample.quality.toFixed(3)
                    }))
                };
                
                this.recordingResults = results;
                this.displayResults();
            }
            
            displayResults() {
                const resultsSection = document.getElementById('downloadSection');
                const resultsPreview = document.getElementById('resultsPreview');
                
                const metadata = this.recordingResults.metadata;
                const preview = `Recording Summary:
Device Type: ${metadata.deviceType}
ROI Type: ${metadata.roiType}
Duration: ${metadata.recordingDuration.toFixed(1)}s
Sample Count: ${metadata.sampleCount}
Sample Rate: ${metadata.sampleRate} Hz
Average Quality: ${metadata.averageQuality}%
Heart Rate: ${metadata.heartRate} BPM
SNR: ${metadata.snr} dB

ZLO Calibration:
Red: ${metadata.zloCalibration.red.toFixed(2)}
Green: ${metadata.zloCalibration.green.toFixed(2)}
Blue: ${metadata.zloCalibration.blue.toFixed(2)}

Data preview (first 5 samples):
${this.recordingResults.data.slice(0, 5).map(sample => 
    `Timestamp: ${sample.timestamp}, RGB: (${sample.red}, ${sample.green}, ${sample.blue}), Quality: ${sample.quality}`
).join('\n')}`;
                
                resultsPreview.textContent = preview;
                resultsSection.style.display = 'block';
            }
            
            downloadResults() {
                if (!this.recordingResults) return;
                
                const jsonData = JSON.stringify(this.recordingResults, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `ppg_recording_${this.deviceType}_${timestamp}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.debugLog(`Downloaded results: ${filename}`);
            }
            
            updateStatus(message, type) {
                const statusElement = document.getElementById('statusMessage');
                statusElement.textContent = message;
                statusElement.className = `status-message status-${type}`;
                
                this.debugLog(`Status (${type}): ${message}`);
            }
            
            startDebugLog() {
                this.debugMessages = [];
                this.debugLog('PPG Recorder initialized');
                this.debugLog('Based on research: "A calibration method for smartphone camera photoplethysmography"');
            }
            
            debugLog(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                this.debugMessages = this.debugMessages || [];
                this.debugMessages.push(logEntry);
                
                // Keep only last 100 messages
                if (this.debugMessages.length > 100) {
                    this.debugMessages.shift();
                }
                
                const debugContent = document.getElementById('debugContent');
                debugContent.textContent = this.debugMessages.join('\n');
                debugContent.scrollTop = debugContent.scrollHeight;
            }
        }
        
        // Initialize the PPG Recorder when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.ppgRecorder = new PPGRecorder();
        });
        
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript,console.log("SW registered")');
        }
    </script>
</body>
</html>