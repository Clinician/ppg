<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research-Based PPG Algorithm Tool</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiUmVzZWFyY2gtQmFzZWQgUFBHIFRvb2wiLCJzaG9ydF9uYW1lIjoiUFBHVG9vbCIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjZmZmZmZmIiwidGhlbWVfY29sb3IiOiIjMDA3Y2ZmIn0=">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #007cff 0%, #0056b3 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .research-notice {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            text-align: center;
            font-weight: 600;
        }

        .main-content {
            padding: 40px;
        }

        .calibration-status {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: #1976d2;
        }

        .calibration-status.uncalibrated {
            background: #fff3e0;
            border-color: #ff9800;
            color: #e65100;
        }

        .calibration-status.calibrated {
            background: #e8f5e8;
            border-color: #4caf50;
            color: #2e7d32;
        }

        .camera-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .camera-container {
            position: relative;
            max-width: 500px;
            margin: 0 auto 20px;
            border-radius: 20px;
            overflow: hidden;
            background: #333;
            border: 3px solid #007cff;
        }

        .camera-preview {
            width: 100%;
            height: 400px;
            object-fit: cover;
            background: #333;
            display: block;
        }

        .camera-placeholder {
            width: 100%;
            height: 400px;
            background: linear-gradient(45deg, #333 25%, #444 25%, #444 50%, #333 50%, #333 75%, #444 75%);
            background-size: 20px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ccc;
            font-size: 1.2rem;
            text-align: center;
            line-height: 1.5;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 1.1rem;
            text-align: center;
            padding: 20px;
        }

        .camera-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .control-group {
            background: white;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007cff 0%, #0056b3 100%);
            color: white;
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            color: #333;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007cff, #0056b3);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .result-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e9ecef;
            position: relative;
        }

        .result-card.optimized {
            border-color: #28a745;
            background: linear-gradient(135deg, #f8fff9 0%, #f0fff4 100%);
        }

        .result-card.original {
            border-color: #007cff;
            background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%);
        }

        .algorithm-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .algorithm-badge.optimized {
            background: #28a745;
            color: white;
        }

        .algorithm-badge.original {
            background: #007cff;
            color: white;
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
        }

        .metric-item.excellent {
            border-color: #4caf50;
            background: linear-gradient(135deg, #e8f5e8 0%, #f0fff4 100%);
        }

        .metric-item.good {
            border-color: #2196f3;
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f8ff 100%);
        }

        .metric-item.poor {
            border-color: #ff9800;
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
        }

        .metric-item.bad {
            border-color: #f44336;
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
        }

        .quality-warning {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
        }

        .quality-good {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .quality-bad {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .comparison-summary {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border: 2px solid #ff9800;
            border-radius: 15px;
            padding: 20px;
            margin: 30px 0;
        }

        .research-reference {
            background: linear-gradient(135deg, #e8eaf6 0%, #f3e5f5 100%);
            border: 2px solid #9c27b0;
            border-radius: 15px;
            padding: 20px;
            margin: 30px 0;
            font-size: 0.9rem;
        }

        #debug-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 0.9rem;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .camera-controls {
                grid-template-columns: 1fr;
            }
            
            .results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Research-Based PPG Algorithm Tool</h1>
            <p>Smartphone Camera Photoplethysmography with Research-Validated Calibration Methods</p>
        </div>
        
        <div class="research-notice">
            Based on "A calibration method for smartphone camera photoplethysmography" (Xuan et al., 2023) - Achieving 74% higher accuracy through proper calibration
        </div>
        
        <div class="main-content">
            <!-- Calibration Status - Now at the top -->
            <div class="calibration-status uncalibrated" id="calibration-status">
                <h3>Camera Calibration Status</h3>
                <p id="calibration-message">Device not calibrated. Please run ZLO calibration for optimal accuracy.</p>
                <div class="camera-controls">
                    <div class="control-group">
                        <button class="btn btn-warning" onclick="startZLOCalibration()">Calibrate Zero Light Offset</button>
                    </div>
                    <div class="control-group">
                        <button class="btn btn-secondary" onclick="loadKnownCalibration()">Load Known Device Calibration</button>
                    </div>
                </div>
            </div>

            <!-- Camera Section - Moved to top and reorganized -->
            <div class="camera-section">
                <h3>Camera Setup & Recording</h3>
                
                <div class="camera-container">
                    <video id="camera-preview" class="camera-preview" autoplay muted style="display: none;"></video>
                    <div id="camera-placeholder" class="camera-placeholder">
                        Camera Not Initialized<br>
                        Click "Initialize Camera" to begin
                    </div>
                    <canvas id="capture-canvas" style="display: none;"></canvas>
                    <div id="camera-overlay" class="camera-overlay" style="display: none;">
                        <div id="signal-quality" style="font-size: 1.3rem; margin-bottom: 15px;">
                            Analyzing signal quality...
                        </div>
                        <div id="quality-details" style="font-size: 0.9rem; opacity: 0.8;">
                            Place fingertip gently over rear camera
                        </div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div id="recording-progress" class="progress-fill"></div>
                </div>

                <div class="camera-controls">
                    <div class="control-group">
                        <h4>Camera Control</h4>
                        <button id="start-camera-btn" class="btn btn-primary" onclick="initCamera()">
                            Initialize Camera
                        </button>
                        <button id="stop-camera-btn" class="btn btn-secondary" onclick="stopCamera()" disabled style="display: none;">
                            Stop Camera
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <h4>PPG Recording</h4>
                        <button id="record-btn" class="btn btn-success" onclick="startRecording()" disabled>
                            Start Recording
                        </button>
                        <button id="stop-record-btn" class="btn btn-danger" onclick="stopRecording()" disabled style="display: none;">
                            Stop Recording
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <h4>Platform</h4>
                        <select id="platform-select" class="btn btn-secondary" style="text-transform: none;">
                            <option value="android">Android (Optimal)</option>
                            <option value="ios">iOS (Limited)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h4>Flash Control</h4>
                        <button id="flash-btn" class="btn btn-secondary" onclick="toggleFlash()" disabled>
                            Turn Flash On
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="results" class="results"></div>
            
            <div id="debug-info">
                <h4>Research Implementation Details:</h4>
                <div id="debug-log"></div>
                <button class="btn btn-secondary" onclick="toggleDebugInfo()" style="margin-top: 10px;">Hide Debug</button>
            </div>
        </div>
    </div>

    <script>
        // Research-based constants and configurations
        const RESEARCH_CONFIG = {
            TONE_MAPPING: 'linear',
            FRAME_RATE: 30,
            EXPOSURE_TIME: 30,
            ISO_SENSITIVITY: 55,
            SENSITIVITY_BOOST: 100,
            WHITE_BALANCE_GAINS: { red: 2, green_even: 1, green_odd: 1, blue: 2 },
            
            KNOWN_ZLO: {
                'pixel_4': -22.5,
                'pixel_7': -14,
                'galaxy_s22': -19.6,
                'moto_g_2022': -14.9
            },
            
            QUALITY_THRESHOLDS: {
                ios: {
                    min_variance: 1.0,
                    min_intensity_range: 5.0,
                    min_brightness: 20,
                    max_brightness: 240,
                    max_variation: 180
                },
                android: {
                    min_signal_quality: 0.05,
                    max_variance: 30,
                    max_intensity: 240,
                    min_intensity: 10,
                    min_range: 5
                }
            }
        };

        // Global state
        let mediaStream = null;
        let videoTrack = null;
        let isRecording = false;
        let recordingFrames = [];
        let currentZLO = 0;
        let isCalibrated = false;
        let cameraCapabilities = {};
        let flashEnabled = false;

        // Debug logging
        function debugLog(message) {
            console.log('[Research PPG]', message);
            const debugDiv = document.getElementById('debug-log');
            if (debugDiv) {
                const timestamp = new Date().toLocaleTimeString();
                debugDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
                document.getElementById('debug-info').style.display = 'block';
            }
        }

        function toggleDebugInfo() {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
        }

        // Camera initialization
        async function initCamera() {
            try {
                debugLog('Initializing camera...');
                
                const constraints = {
                    video: {
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: RESEARCH_CONFIG.FRAME_RATE }
                    }
                };

                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoTrack = mediaStream.getVideoTracks()[0];
                
                cameraCapabilities = videoTrack.getCapabilities();
                
                const video = document.getElementById('camera-preview');
                const placeholder = document.getElementById('camera-placeholder');
                
                video.srcObject = mediaStream;
                
                // Show video, hide placeholder
                video.style.display = 'block';
                placeholder.style.display = 'none';
                
                // Update UI
                document.getElementById('start-camera-btn').style.display = 'none';
                document.getElementById('stop-camera-btn').style.display = 'inline-block';
                document.getElementById('stop-camera-btn').disabled = false;
                document.getElementById('record-btn').disabled = false;
                
                // Flash control
                if (cameraCapabilities.torch) {
                    document.getElementById('flash-btn').disabled = false;
                }
                
                debugLog('Camera initialized successfully');
                
            } catch (error) {
                debugLog(`Camera initialization failed: ${error.message}`);
                showError('Camera access failed: ' + error.message);
            }
        }

        // Stop camera and auto-cleanup after recording
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
                videoTrack = null;
            }
            
            const video = document.getElementById('camera-preview');
            const placeholder = document.getElementById('camera-placeholder');
            
            // Hide video, show placeholder
            video.style.display = 'none';
            video.srcObject = null;
            placeholder.style.display = 'flex';
            placeholder.textContent = 'Camera Stopped\nClick "Initialize Camera" to restart';
            
            // Reset UI
            document.getElementById('start-camera-btn').style.display = 'inline-block';
            document.getElementById('stop-camera-btn').style.display = 'none';
            document.getElementById('record-btn').disabled = true;
            document.getElementById('flash-btn').disabled = true;
            document.getElementById('flash-btn').textContent = 'Turn Flash On';
            
            flashEnabled = false;
            debugLog('Camera stopped and cleaned up');
        }

        // Flash control (fixed)
        async function toggleFlash() {
            if (!videoTrack || !cameraCapabilities.torch) {
                debugLog('Flash not available');
                return;
            }
            
            try {
                const constraints = {
                    advanced: [{ torch: !flashEnabled }]
                };
                
                await videoTrack.applyConstraints(constraints);
                
                flashEnabled = !flashEnabled;
                const flashBtn = document.getElementById('flash-btn');
                flashBtn.textContent = flashEnabled ? 'Turn Flash Off' : 'Turn Flash On';
                
                debugLog(`Flash ${flashEnabled ? 'enabled' : 'disabled'}`);
                
            } catch (error) {
                debugLog(`Flash control failed: ${error.message}`);
            }
        }

        // ZLO Calibration
        async function startZLOCalibration() {
            try {
                debugLog('Starting ZLO calibration...');
                
                if (!mediaStream) {
                    alert('Please initialize camera first');
                    return;
                }
                
                const proceed = confirm(
                    'ZLO Calibration Process:\n\n' +
                    '1. Completely cover the camera lens with your finger\n' +
                    '2. Ensure no light reaches the sensor\n' +
                    '3. Click OK to start measurement\n\n' +
                    'This measures the sensor\'s zero-light offset for accurate PPG calculations.'
                );
                
                if (!proceed) return;
                
                // Measure ZLO
                const measurements = [];
                const video = document.getElementById('camera-preview');
                const canvas = document.getElementById('capture-canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                
                for (let i = 0; i < 10; i++) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = Array.from(imageData.data);
                    
                    let sum = 0;
                    for (let j = 0; j < pixels.length; j += 4) {
                        sum += pixels[j] + pixels[j+1] + pixels[j+2];
                    }
                    const avgPixelValue = sum / (pixels.length * 3 / 4);
                    measurements.push(avgPixelValue);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                currentZLO = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                isCalibrated = true;
                
                debugLog(`ZLO calibrated: ${currentZLO.toFixed(2)}`);
                updateCalibrationStatus();
                
            } catch (error) {
                debugLog(`ZLO calibration failed: ${error.message}`);
                showError('Calibration failed: ' + error.message);
            }
        }

        // Load known calibration
        function loadKnownCalibration() {
            const device = prompt(
                'Enter device model:\n\n' +
                '- pixel_4 (ZLO: -22.5)\n' +
                '- pixel_7 (ZLO: -14)\n' +
                '- galaxy_s22 (ZLO: -19.6)\n' +
                '- moto_g_2022 (ZLO: -14.9)\n\n' +
                'Or enter custom ZLO value:'
            );
            
            if (!device) return;
            
            if (RESEARCH_CONFIG.KNOWN_ZLO[device.toLowerCase()]) {
                currentZLO = RESEARCH_CONFIG.KNOWN_ZLO[device.toLowerCase()];
                isCalibrated = true;
                debugLog(`Loaded calibration for ${device}: ZLO = ${currentZLO}`);
            } else {
                const customZLO = parseFloat(device);
                if (!isNaN(customZLO)) {
                    currentZLO = customZLO;
                    isCalibrated = true;
                    debugLog(`Custom ZLO calibration: ${currentZLO}`);
                } else {
                    alert('Invalid device or ZLO value');
                    return;
                }
            }
            
            updateCalibrationStatus();
        }

        // Update calibration status
        function updateCalibrationStatus() {
            const statusEl = document.getElementById('calibration-status');
            const messageEl = document.getElementById('calibration-message');
            
            if (isCalibrated) {
                statusEl.className = 'calibration-status calibrated';
                messageEl.textContent = `Device calibrated. ZLO: ${currentZLO.toFixed(2)} (Research-validated accuracy improvement expected)`;
            } else {
                statusEl.className = 'calibration-status uncalibrated';
                messageEl.textContent = 'Device not calibrated. PPG measurements may be inaccurate without ZLO correction.';
            }
        }

        // PPG Processing - Both Original and Optimized
        function processWithBothAlgorithms(imageData, timestamp) {
            const platform = document.getElementById('platform-select').value;
            const canvas = document.getElementById('capture-canvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // Process with original algorithm
            const originalResult = processOriginalPPG(imageData, width, height, platform, timestamp);
            
            // Process with optimized algorithm  
            const optimizedResult = processOptimizedPPG(imageData, width, height, platform, timestamp);
            
            return {
                original: originalResult,
                optimized: optimizedResult
            };
        }

        // Original Algorithm Processing
        function processOriginalPPG(imageData, width, height, platform, timestamp) {
            const pixels = Array.from(imageData.data);
            const nROIs = 3;
            const ppgValues = new Array(3 * nROIs + 3).fill(0);
            
            // Simple grid-based ROI extraction (original method)
            const wStep = Math.floor(width / nROIs);
            const hStep = Math.floor(height / nROIs);
            
            for (let r = 0; r < nROIs; r++) {
                let rSum = 0, gSum = 0, bSum = 0, pixelCount = 0;
                
                const xStart = r * wStep;
                const xEnd = Math.min(xStart + wStep, width);
                const yStart = 0;
                const yEnd = Math.min(hStep, height);
                
                for (let y = yStart; y < yEnd; y++) {
                    for (let x = xStart; x < xEnd; x++) {
                        const index = (y * width + x) * 4;
                        if (index < pixels.length - 3) {
                            rSum += pixels[index];
                            gSum += pixels[index + 1];
                            bSum += pixels[index + 2];
                            pixelCount++;
                        }
                    }
                }
                
                if (pixelCount > 0) {
                    const avgR = rSum / pixelCount;
                    const avgG = gSum / pixelCount;
                    const avgB = bSum / pixelCount;
                    
                    // Convert to YUV
                    const Y = 0.299 * avgR + 0.587 * avgG + 0.114 * avgB;
                    const U = -0.14713 * avgR - 0.28886 * avgG + 0.436 * avgB + 128;
                    const V = 0.615 * avgR - 0.51499 * avgG - 0.10001 * avgB + 128;
                    
                    if (platform === 'ios') {
                        // Original iOS: only Y channel (value-0-0 pattern)
                        ppgValues[3 * r] = Y;
                        ppgValues[3 * r + 1] = 0;
                        ppgValues[3 * r + 2] = 0;
                    } else {
                        // Original Android: Y-U-V channels
                        ppgValues[3 * r] = Y;
                        ppgValues[3 * r + 1] = U;
                        ppgValues[3 * r + 2] = V;
                    }
                }
            }
            
            // Original algorithm always returns "Good" quality (hardcoded)
            return {
                timestamp,
                ppgSignals: ppgValues,
                quality: { score: 100, grade: 'excellent', reasons: [] },
                qualityWarning: false,
                qualityReason: 'Original algorithm always returns "Good" (hardcoded)',
                platform,
                algorithm: 'original'
            };
        }

        // Optimized Algorithm Processing
        function processOptimizedPPG(imageData, width, height, platform, timestamp) {
            const pixels = Array.from(imageData.data);
            const nROIs = 3;
            const ppgValues = new Array(3 * nROIs + 3).fill(0);
            
            // Enhanced circular ROI extraction for better signal capture
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);
            const maxRadius = Math.min(width, height) / 4;
            
            let signalValues = [];
            
            for (let r = 0; r < nROIs; r++) {
                let rSum = 0, gSum = 0, bSum = 0, pixelCount = 0;
                
                const radius = (r + 1) * maxRadius / nROIs;
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx*dx + dy*dy <= radius*radius) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            
                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                const index = (Math.floor(y) * width + Math.floor(x)) * 4;
                                if (index < pixels.length - 3) {
                                    rSum += pixels[index];
                                    gSum += pixels[index + 1];
                                    bSum += pixels[index + 2];
                                    pixelCount++;
                                }
                            }
                        }
                    }
                }
                
                if (pixelCount > 0) {
                    const avgR = rSum / pixelCount;
                    const avgG = gSum / pixelCount;
                    const avgB = bSum / pixelCount;
                    
                    // Convert to YUV and apply ZLO correction
                    let Y = 0.299 * avgR + 0.587 * avgG + 0.114 * avgB;
                    let U = -0.14713 * avgR - 0.28886 * avgG + 0.436 * avgB + 128;
                    let V = 0.615 * avgR - 0.51499 * avgG - 0.10001 * avgB + 128;
                    
                    // Apply ZLO correction if calibrated
                    if (isCalibrated) {
                        Y = Math.max(0, Y - currentZLO);
                        U = Math.max(0, U - currentZLO);
                        V = Math.max(0, V - currentZLO);
                    }
                    
                    if (platform === 'ios') {
                        // Optimized iOS: still maintains value-0-0 pattern
                        ppgValues[3 * r] = Y;
                        ppgValues[3 * r + 1] = 0;
                        ppgValues[3 * r + 2] = 0;
                        signalValues.push(Y);
                    } else {
                        // Optimized Android: enhanced Y-U-V processing
                        ppgValues[3 * r] = Y;
                        ppgValues[3 * r + 1] = U;
                        ppgValues[3 * r + 2] = V;
                        signalValues.push(Y, U, V);
                    }
                }
            }
            
            // Enhanced quality assessment
            const qualityResult = assessSignalQuality(signalValues, platform);
            
            return {
                timestamp,
                ppgSignals: ppgValues,
                quality: qualityResult,
                qualityWarning: qualityResult.score < 50,
                qualityReason: qualityResult.reasons.length > 0 ? qualityResult.reasons.join('; ') : 'Good signal quality',
                platform,
                algorithm: 'optimized'
            };
        }

        // Enhanced quality assessment
        function assessSignalQuality(signalValues, platform) {
            if (signalValues.length === 0) {
                return {
                    score: 0,
                    grade: 'bad',
                    reasons: ['No signal values detected'],
                    metrics: {}
                };
            }
            
            const thresholds = RESEARCH_CONFIG.QUALITY_THRESHOLDS[platform];
            const mean = signalValues.reduce((a, b) => a + b, 0) / signalValues.length;
            const variance = signalValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / signalValues.length;
            const stdDev = Math.sqrt(variance);
            const range = Math.max(...signalValues) - Math.min(...signalValues);
            
            let qualityScore = 0;
            let qualityReasons = [];
            let passedTests = 0;
            const totalTests = 4;
            
            if (platform === 'ios') {
                if (stdDev >= thresholds.min_variance) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Low variance (${stdDev.toFixed(2)} < ${thresholds.min_variance})`);
                }
                
                if (range >= thresholds.min_intensity_range) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Low range (${range.toFixed(1)} < ${thresholds.min_intensity_range})`);
                }
                
                if (mean >= thresholds.min_brightness && mean <= thresholds.max_brightness) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Brightness out of range (${mean.toFixed(1)} not in ${thresholds.min_brightness}-${thresholds.max_brightness})`);
                }
                
                if (range <= thresholds.max_variation) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Too much variation (${range.toFixed(1)} > ${thresholds.max_variation})`);
                }
            } else { // Android
                const signalQuality = (mean * variance) / (255 * 255);
                
                if (signalQuality >= thresholds.min_signal_quality) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Poor signal quality (${(signalQuality*100).toFixed(1)}% < ${thresholds.min_signal_quality*100}%)`);
                }
                
                if (stdDev <= thresholds.max_variance) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Excessive noise (${stdDev.toFixed(1)} > ${thresholds.max_variance})`);
                }
                
                if (mean <= thresholds.max_intensity && mean >= thresholds.min_intensity) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Intensity out of range (${mean.toFixed(1)} not in ${thresholds.min_intensity}-${thresholds.max_intensity})`);
                }
                
                if (range >= thresholds.min_range) {
                    qualityScore += 25;
                    passedTests++;
                } else {
                    qualityReasons.push(`Insufficient range (${range.toFixed(1)} < ${thresholds.min_range})`);
                }
            }
            
            let grade;
            if (qualityScore >= 75) grade = 'excellent';
            else if (qualityScore >= 50) grade = 'good';
            else if (qualityScore >= 25) grade = 'poor';
            else grade = 'bad';
            
            debugLog(`Quality Assessment: ${qualityScore}% (${passedTests}/${totalTests} tests passed) - Grade: ${grade}`);
            
            return {
                score: qualityScore,
                grade: grade,
                reasons: qualityReasons,
                metrics: { mean, variance, stdDev, range, passedTests, totalTests }
            };
        }

        // Start recording with both algorithms
        async function startRecording() {
            if (!mediaStream) {
                alert('Please initialize camera first');
                return;
            }
            
            try {
                debugLog('Starting PPG recording with both algorithms...');
                isRecording = true;
                recordingFrames = [];
                
                document.getElementById('record-btn').disabled = true;
                document.getElementById('stop-record-btn').style.display = 'inline-block';
                document.getElementById('stop-record-btn').disabled = false;
                document.getElementById('camera-overlay').style.display = 'flex';
                
                const video = document.getElementById('camera-preview');
                const canvas = document.getElementById('capture-canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                
                let frameCount = 0;
                const recordingDuration = 10000; // 10 seconds
                const startTime = Date.now();
                
                const recordingInterval = setInterval(() => {
                    if (!isRecording) {
                        clearInterval(recordingInterval);
                        return;
                    }
                    
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min((elapsed / recordingDuration) * 100, 100);
                    document.getElementById('recording-progress').style.width = progress + '%';
                    
                    // Capture frame
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Process with both algorithms
                    const results = processWithBothAlgorithms(imageData, Date.now());
                    recordingFrames.push(results);
                    
                    // Update real-time display
                    updateQualityDisplay(results.optimized.quality);
                    
                    frameCount++;
                    
                    if (elapsed >= recordingDuration) {
                        stopRecording();
                    }
                    
                }, 1000 / RESEARCH_CONFIG.FRAME_RATE);
                
            } catch (error) {
                debugLog(`Recording failed: ${error.message}`);
                showError('Recording failed: ' + error.message);
                resetRecordingUI();
            }
        }

        // Update real-time quality display
        function updateQualityDisplay(quality) {
            const signalEl = document.getElementById('signal-quality');
            const detailsEl = document.getElementById('quality-details');
            
            const gradeEmojis = {
                excellent: 'Excellent',
                good: 'Good', 
                poor: 'Poor',
                bad: 'Bad'
            };
            
            signalEl.textContent = `Signal Quality: ${quality.score}% (${gradeEmojis[quality.grade]})`;
            
            if (quality.reasons.length > 0) {
                detailsEl.textContent = `Issues: ${quality.reasons.join(', ')}`;
            } else {
                detailsEl.textContent = 'All quality metrics passed';
            }
        }

        // Stop recording
        function stopRecording() {
            debugLog('Stopping recording...');
            isRecording = false;
            resetRecordingUI();
            
            // Auto-disable flash and stop camera after recording
            if (flashEnabled && videoTrack) {
                toggleFlash();
            }
            
            // Auto-stop camera after recording
            setTimeout(() => {
                stopCamera();
            }, 1000);
            
            if (recordingFrames.length > 0) {
                showBothResults();
            } else {
                showError('No frames captured');
            }
        }

        // Reset recording UI
        function resetRecordingUI() {
            document.getElementById('record-btn').disabled = false;
            document.getElementById('stop-record-btn').style.display = 'none';
            document.getElementById('camera-overlay').style.display = 'none';
            document.getElementById('recording-progress').style.width = '0%';
        }

        // Show results from both algorithms
        function showBothResults() {
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';
            
            if (recordingFrames.length === 0) return;
            
            // Add comparison summary
            const comparisonCard = document.createElement('div');
            comparisonCard.className = 'comparison-summary';
            comparisonCard.innerHTML = `
                <h3>Algorithm Comparison Results</h3>
                <p><strong>Frames Processed:</strong> ${recordingFrames.length}</p>
                <p><strong>Platform:</strong> ${document.getElementById('platform-select').value.toUpperCase()}</p>
                <p><strong>Calibration Status:</strong> ${isCalibrated ? `ZLO: ${currentZLO.toFixed(2)}` : 'Not calibrated'}</p>
                <div style="margin-top: 15px;">
                    <strong>Key Difference:</strong> Original algorithm always reports "Good" quality (hardcoded), 
                    while optimized algorithm provides actual quality assessment based on signal analysis.
                </div>
            `;
            resultsContainer.appendChild(comparisonCard);
            
            // Show original results
            displayAlgorithmResults('original', recordingFrames);
            
            // Show optimized results
            displayAlgorithmResults('optimized', recordingFrames);
            
            debugLog(`Processed ${recordingFrames.length} frames with both algorithms`);
        }

        // Display results for a specific algorithm
        function displayAlgorithmResults(algorithmType, frames) {
            const resultsContainer = document.getElementById('results');
            
            const firstFrame = frames[0][algorithmType];
            const platform = firstFrame.platform;
            
            // Calculate average quality for optimized algorithm
            let avgQuality = 100; // Original is always 100%
            if (algorithmType === 'optimized') {
                avgQuality = frames.reduce((sum, frame) => sum + frame.optimized.quality.score, 0) / frames.length;
            }
            
            const resultCard = document.createElement('div');
            resultCard.className = `result-card ${algorithmType}`;
            resultCard.innerHTML = `
                <div class="algorithm-badge ${algorithmType}">${algorithmType.toUpperCase()}</div>
                <h3>${algorithmType.toUpperCase()} Algorithm Results (${platform.toUpperCase()})</h3>
                
                <div class="quality-metrics">
                    <div class="metric-item ${avgQuality >= 75 ? 'excellent' : avgQuality >= 50 ? 'good' : 'poor'}">
                        <h4>Quality Score</h4>
                        <div style="font-size: 1.5rem; font-weight: bold;">${avgQuality.toFixed(1)}%</div>
                    </div>
                    
                    <div class="metric-item ${isCalibrated ? 'excellent' : 'bad'}">
                        <h4>ZLO Applied</h4>
                        <div style="font-size: 1.2rem; font-weight: bold;">
                            ${algorithmType === 'optimized' && isCalibrated ? `Yes (${currentZLO.toFixed(2)})` : 'No'}
                        </div>
                    </div>
                    
                    <div class="metric-item good">
                        <h4>Frames</h4>
                        <div style="font-size: 1.5rem; font-weight: bold;">${frames.length}</div>
                    </div>
                    
                    <div class="metric-item ${algorithmType === 'optimized' ? 'good' : 'poor'}">
                        <h4>Assessment</h4>
                        <div style="font-size: 1.2rem; font-weight: bold;">
                            ${algorithmType === 'optimized' ? 'Real Analysis' : 'Hardcoded'}
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h4>PPG Signal Array (First Frame)</h4>
                    <div style="background: white; padding: 15px; border-radius: 10px; margin-top: 10px;">
                        <div style="margin: 10px 0; font-family: monospace; background: #f5f5f5; padding: 10px; border-radius: 5px;">
                            <strong>PPG Signals [0-14]:</strong><br>
                            ${firstFrame.ppgSignals.slice(0, 15).map((signal, i) => {
                                const value = signal.toFixed(1);
                                const channelType = i % 3 === 0 ? 'Y' : i % 3 === 1 ? 'U' : 'V';
                                const highlight = platform === 'ios' && i % 3 !== 0 ? 'color: #999; opacity: 0.6;' : 'color: #000;';
                                return `<span style="${highlight}" title="${channelType}">${value}</span>`;
                            }).join(', ')}
                        </div>
                        <p style="font-size: 0.9rem; color: #666;">
                            ${platform === 'ios' ? 
                                'iOS Pattern: Only Y-channel values (every 3rd element), U/V channels remain 0' :
                                'Android Pattern: All Y-U-V channels filled with processed values'
                            }
                        </p>
                    </div>
                </div>
                
                <div class="quality-warning ${firstFrame.qualityWarning ? 'quality-bad' : 'quality-good'}">
                    <strong>Quality Assessment:</strong> ${firstFrame.qualityWarning ? 'Warning - Poor Signal' : 'Good Signal Quality'}<br>
                    <small>Reason: ${firstFrame.qualityReason}</small>
                </div>
            `;
            
            resultsContainer.appendChild(resultCard);
        }

        // Error handling
        function showError(message) {
            alert('Error: ' + message);
            debugLog(`Error: ${message}`);
        }

        // Initialize
        updateCalibrationStatus();
        debugLog('Research-based PPG Tool initialized');
    </script>
</body>
</html>