<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPG Signal Recorder</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 400px; margin: 0 auto; padding: 10px; background: #f5f5f5; }
        .section { margin-bottom: 20px; border: 1px solid #ccc; padding: 10px; background: #fff; border-radius: 5px; }
        .config-group { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        button { padding: 8px 12px; border: none; background: #007bff; color: #fff; border-radius: 4px; cursor: pointer; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .metrics { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .metric { text-align: center; font-size: 14px; }
        #recordingInProgress { color: red; font-weight: bold; display: none; margin-top: 10px; }
        #debugInfo { display: none; white-space: pre-wrap; font-size: 12px; background: #f8f8f8; padding: 10px; }
        #videoContainer { position: relative; width: 100%; aspect-ratio: 4/3; }
        #video { width: 100%; height: 100%; border: 1px solid #ccc; border-radius: 4px; }
        #roiOverlay { position: absolute; top: 0; left: 0; pointer-events: none; border: 2px solid red; box-sizing: border-box; }
        #signalPlot { width: 100%; height: 200px; border: 1px solid #ccc; border-radius: 4px; }
        .tab button { background: #f1f1f1; border: 1px solid #ccc; padding: 8px; flex: 1; }
        .tab button.active { background: #007bff; color: #fff; }
        .tab { display: flex; gap: 5px; }
        input[type="range"] { width: 60%; }
        .slider-value { margin-left: 10px; font-size: 14px; }
        h3 { margin-top: 0; }
        p { margin: 5px 0; }
    </style>
</head>
<body>
    <h1>PPG Signal Recorder</h1>
    <p>Professional smartphone-based photoplethysmography recording</p>

    <div class="section">
        <h3>Device Configuration</h3>
        <div class="tab">
            <button class="tablinks active" onclick="selectPlatform(event, 'Android')">Android</button>
            <button class="tablinks" onclick="selectPlatform(event, 'iOS')">iOS</button>
        </div>
    </div>

    <div class="section">
        <h3>ROI Configuration</h3>
        <div class="config-group">
            <label>ROI Type:</label>
            <select id="roiType" onchange="updateROIOverlay()">
                <option>Rectangle</option>
                <option>Circular</option>
            </select>
        </div>
        <div class="config-group">
            <label>ROI X Position:</label>
            <input type="range" id="roiX" min="0" max="100" value="25" oninput="updateSliderValue('roiXValue', this.value); updateROIOverlay()">
            <span id="roiXValue" class="slider-value">25%</span>
        </div>
        <div class="config-group">
            <label>ROI Y Position:</label>
            <input type="range" id="roiY" min="0" max="100" value="25" oninput="updateSliderValue('roiYValue', this.value); updateROIOverlay()">
            <span id="roiYValue" class="slider-value">25%</span>
        </div>
        <div class="config-group">
            <label>ROI Width:</label>
            <input type="range" id="roiWidth" min="10" max="100" value="50" oninput="updateSliderValue('roiWidthValue', this.value); updateROIOverlay()">
            <span id="roiWidthValue" class="slider-value">50%</span>
        </div>
        <div class="config-group">
            <label>ROI Height:</label>
            <input type="range" id="roiHeight" min="10" max="100" value="50" oninput="updateSliderValue('roiHeightValue', this.value); updateROIOverlay()">
            <span id="roiHeightValue" class="slider-value">50%</span>
        </div>
        <div class="config-group">
            <label>Recording Duration:</label>
            <input type="range" id="duration" min="5" max="60" value="10" oninput="updateSliderValue('durationValue', this.value)">
            <span id="durationValue" class="slider-value">10s</span>
        </div>
    </div>

    <div class="section">
        <h3>Camera Preview</h3>
        <div id="videoContainer">
            <video id="video" autoplay muted playsinline></video>
            <div id="roiOverlay"></div>
        </div>
    </div>

    <div class="section">
        <h3>Signal Quality Monitor</h3>
        <p id="monitorStatus">Android selected - click Start Camera</p>
        <div class="metrics">
            <div class="metric">
                <label>Heart Rate (bpm)</label><br>
                <span id="heartRate">--</span>
            </div>
            <div class="metric">
                <label>SNR (dB)</label><br>
                <span id="snr">--</span>
            </div>
            <div class="metric">
                <label>Signal Strength</label><br>
                <span id="signalStrength">--</span>
            </div>
            <div class="metric">
                <label>DC Component</label><br>
                <span id="dcComponent">--</span>
            </div>
        </div>
        <h4>PPG Signal Waveform</h4>
        <canvas id="signalPlot"></canvas>
    </div>

    <div class="section">
        <button id="startCamera">Start Camera</button>
        <button id="startSignalMonitor" disabled>Start Signal Monitor</button>
        <button id="startRecording" disabled>Start Recording</button>
        <button id="stop">Stop</button>
        <button id="calibrateZLO">Calibrate ZLO</button>
        <button id="reset">Reset</button>
        <div id="recordingInProgress">RECORDING IN PROGRESS...</div>
    </div>

    <div class="section">
        <h3>Recording Results</h3>
        <button id="downloadPPG" disabled>Download PPG Data</button>
    </div>

    <div class="section">
        <button id="toggleDebug">Debug Information (Click to toggle)</button>
        <div id="debugInfo"></div>
    </div>

    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        // DOM Elements
        const video = document.getElementById('video');
        const videoContainer = document.getElementById('videoContainer');
        const roiOverlay = document.getElementById('roiOverlay');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const plotCanvas = document.getElementById('signalPlot');
        const plotCtx = plotCanvas.getContext('2d');
        const startCameraBtn = document.getElementById('startCamera');
        const startMonitorBtn = document.getElementById('startSignalMonitor');
        const startRecordBtn = document.getElementById('startRecording');
        const stopBtn = document.getElementById('stop');
        const calibrateBtn = document.getElementById('calibrateZLO');
        const resetBtn = document.getElementById('reset');
        const downloadBtn = document.getElementById('downloadPPG');
        const recordingEl = document.getElementById('recordingInProgress');
        const monitorStatusEl = document.getElementById('monitorStatus');
        const hrEl = document.getElementById('heartRate');
        const snrEl = document.getElementById('snr');
        const strengthEl = document.getElementById('signalStrength');
        const dcEl = document.getElementById('dcComponent');
        const debugEl = document.getElementById('debugInfo');
        const toggleDebugBtn = document.getElementById('toggleDebug');
        const roiTypeEl = document.getElementById('roiType');
        const roiXEl = document.getElementById('roiX');
        const roiYEl = document.getElementById('roiY');
        const roiWidthEl = document.getElementById('roiWidth');
        const roiHeightEl = document.getElementById('roiHeight');
        const durationEl = document.getElementById('duration');
        const tabButtons = document.querySelectorAll('.tablinks');

        // State
        let platform = 'Android';
        let zlo = { r: 0, g: 0, b: 0 }; // Separate ZLO for each channel
        let signal = [];
        let startTime = 0;
        let recordingStartTime = 0;
        let samplingTimer = null;
        let recordingTimer = null;
        let isMonitoring = false;
        let isRecording = false;
        let stream = null;
        const samplingRate = 30; // Hz
        const intervalMs = 1000 / samplingRate;
        let torchTrack = null;

        // Platform selection
        function selectPlatform(event, selected) {
            platform = selected;
            tabButtons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            monitorStatusEl.textContent = `${selected} selected - click Start Camera`;
            logDebug(`Platform selected: ${selected}`);
        }

        // Debug toggle
        toggleDebugBtn.onclick = () => {
            debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
        };

        function logDebug(msg) {
            debugEl.textContent += new Date().toISOString() + ': ' + msg + '\n';
        }

        // Update slider value display
        function updateSliderValue(id, value) {
            document.getElementById(id).textContent = id.includes('duration') ? value + 's' : value + '%';
        }

        // Update ROI Overlay
        function updateROIOverlay() {
            if (!video.videoWidth) return;
            const vidRect = video.getBoundingClientRect();
            const roiX = (parseFloat(roiXEl.value) / 100) * vidRect.width;
            const roiY = (parseFloat(roiYEl.value) / 100) * vidRect.height;
            const roiW = (parseFloat(roiWidthEl.value) / 100) * vidRect.width;
            const roiH = (parseFloat(roiHeightEl.value) / 100) * vidRect.height;
            roiOverlay.style.left = `${roiX}px`;
            roiOverlay.style.top = `${roiY}px`;
            roiOverlay.style.width = `${roiW}px`;
            roiOverlay.style.height = `${roiH}px`;
            if (roiTypeEl.value === 'Circular') {
                roiOverlay.style.borderRadius = '50%';
            } else {
                roiOverlay.style.borderRadius = '0';
            }
            logDebug(`ROI updated: x=${roiX.toFixed(0)}, y=${roiY.toFixed(0)}, w=${roiW.toFixed(0)}, h=${roiH.toFixed(0)}`);
        }

        // Start Camera (no flash)
        startCameraBtn.onclick = async () => {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = async () => {
                    try {
                        await video.play();
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        plotCanvas.width = plotCanvas.clientWidth;
                        plotCanvas.height = 200;
                        monitorStatusEl.textContent = 'Camera started. Calibrate ZLO (optional, no flash), then start SQM.';
                        startMonitorBtn.disabled = false;
                        calibrateBtn.disabled = false;
                        torchTrack = stream.getVideoTracks()[0];
                        try {
                            await torchTrack.applyConstraints({ advanced: [{ torch: false }] });
                            logDebug('Flash ensured off on camera start');
                        } catch (e) {
                            logDebug('Flash control not supported: ' + e.message);
                        }
                        updateROIOverlay();
                        logDebug(`Camera initialized: ${canvas.width}x${canvas.height}, frameRate=30`);
                    } catch (e) {
                        alert('Video play failed: ' + e.message);
                        logDebug('Video play error: ' + e.message);
                    }
                };
            } catch (err) {
                alert('Camera access failed: ' + err.message + '. Please check permissions and try again.');
                logDebug('Camera error: ' + err.message);
            }
        };

        // Get ROI RGB averages
        function getROIRGB() {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const roiType = roiTypeEl.value;
            const roiX = (parseFloat(roiXEl.value) / 100) * canvas.width;
            const roiY = (parseFloat(roiYEl.value) / 100) * canvas.height;
            const roiW = (parseFloat(roiWidthEl.value) / 100) * canvas.width;
            const roiH = (parseFloat(roiHeightEl.value) / 100) * canvas.height;

            let sumR = 0, sumG = 0, sumB = 0;
            let count = 0;

            const cx = roiX + roiW / 2;
            const cy = roiY + roiH / 2;
            const r = Math.min(roiW, roiH) / 2;

            for (let py = Math.max(0, Math.floor(roiY)); py < Math.min(canvas.height, roiY + roiH); py++) {
                for (let px = Math.max(0, Math.floor(roiX)); px < Math.min(canvas.width, roiX + roiW); px++) {
                    let include = false;
                    if (roiType === 'Rectangle') {
                        include = true;
                    } else {
                        const dx = px - cx;
                        const dy = py - cy;
                        if (dx * dx + dy * dy <= r * r) include = true;
                    }
                    if (include) {
                        const idx = (py * canvas.width + px) * 4;
                        sumR += data[idx];
                        sumG += data[idx + 1];
                        sumB += data[idx + 2];
                        count++;
                    }
                }
            }
            return count > 0 ? {
                r: sumR / count - zlo.r,
                g: sumG / count - zlo.g,
                b: sumB / count - zlo.b
            } : { r: 0, g: 0, b: 0 };
        }

        // Sample loop
        function sample() {
            if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                logDebug('Video not ready for sampling');
                return;
            }
            const { r, g, b } = getROIRGB();
            const time = (Date.now() - startTime) / 1000;
            signal.push({ time, r, g, b });
            updateSQM(g);
            plotSignal();
            logDebug(`Sample: t=${time.toFixed(3)}, r=${r.toFixed(2)}, g=${g.toFixed(2)}, b=${b.toFixed(2)}`);
            if (isRecording && (Date.now() - recordingStartTime) >= parseInt(durationEl.value) * 1000) {
                stopRecording();
                stop(); // Stop SQM after recording
            }
        }

        // Plot signal (green channel)
        function plotSignal() {
            plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);
            if (signal.length < 2) return;
            const values = signal.map(s => s.g);
            const minV = Math.min(...values);
            const maxV = Math.max(...values);
            const range = maxV - minV || 1;
            plotCtx.beginPath();
            plotCtx.strokeStyle = '#28a745';
            plotCtx.lineWidth = 2;
            const step = plotCanvas.width / Math.min(signal.length - 1, samplingRate * 10); // Last 10s
            const startIdx = Math.max(0, signal.length - samplingRate * 10);
            plotCtx.moveTo(0, plotCanvas.height - ((values[startIdx] - minV) / range) * plotCanvas.height);
            for (let i = startIdx + 1; i < signal.length; i++) {
                const x = (i - startIdx) * step;
                const y = plotCanvas.height - ((values[i] - minV) / range) * plotCanvas.height;
                plotCtx.lineTo(x, y);
            }
            plotCtx.stroke();
        }

        // Update SQM (using green channel)
        function updateSQM(green) {
            if (signal.length < samplingRate) return;
            const windowSize = Math.min(samplingRate * 10, signal.length); // Last 10s
            const window = signal.slice(-windowSize);
            const values = window.map(s => s.g);
            const dc = values.reduce((a, b) => a + b, 0) / values.length;
            const ac = values.map(v => v - dc);
            const strength = Math.max(...ac) - Math.min(...ac);

            // Simple DFT for heart rate
            const fft = dft(ac);
            const N = ac.length;
            const df = samplingRate / N;
            const lowBin = Math.round(0.8 / df); // 0.8 Hz (48 bpm)
            const highBin = Math.round(3 / df); // 3 Hz (180 bpm)
            let maxPower = 0;
            let maxK = 0;
            let signalPower = 0;
            let noisePower = 0;
            for (let k = 1; k < N / 2; k++) {
                const power = fft[k] ** 2;
                if (k >= lowBin && k <= highBin) {
                    signalPower += power;
                    if (power > maxPower) {
                        maxPower = power;
                        maxK = k;
                    }
                } else {
                    noisePower += power;
                }
            }
            const hr = maxK * df * 60;
            const snr = signalPower > 0 && noisePower > 0 ? 10 * Math.log10(signalPower / noisePower) : 0;

            hrEl.textContent = isFinite(hr) ? hr.toFixed(1) : '--';
            snrEl.textContent = isFinite(snr) ? snr.toFixed(1) : '--';
            strengthEl.textContent = isFinite(strength) ? strength.toFixed(2) : '--';
            dcEl.textContent = isFinite(dc) ? dc.toFixed(2) : '--';
        }

        function dft(signal) {
            const N = signal.length;
            const freqs = new Array(N).fill(0);
            for (let k = 0; k < N; k++) {
                let re = 0, im = 0;
                for (let n = 0; n < N; n++) {
                    const angle = 2 * Math.PI * k * n / N;
                    re += signal[n] * Math.cos(angle);
                    im -= signal[n] * Math.sin(angle);
                }
                freqs[k] = Math.sqrt(re * re + im * im) / N;
            }
            return freqs;
        }

        // Start Signal Monitor (flash on, 30s max)
        startMonitorBtn.onclick = async () => {
            if (samplingTimer || !stream) {
                alert('Camera not started or already monitoring.');
                return;
            }
            startTime = Date.now();
            signal = [];
            if (platform === 'Android' && torchTrack) {
                try {
                    await torchTrack.applyConstraints({ advanced: [{ torch: true }] });
                    logDebug('Flash enabled for SQM');
                } catch (e) {
                    logDebug('Flash enable failed: ' + e.message);
                    alert('Flash not available: ' + e.message);
                }
            }
            samplingTimer = setInterval(sample, intervalMs);
            isMonitoring = true;
            startMonitorBtn.disabled = true;
            startRecordBtn.disabled = false;
            calibrateBtn.disabled = true;
            monitorStatusEl.textContent = 'SQM running... Cover camera with finger for PPG.';
            logDebug('SQM started');
            setTimeout(() => {
                if (isMonitoring && !isRecording) {
                    stop();
                    monitorStatusEl.textContent = 'SQM timed out after 30s.';
                    logDebug('SQM timed out');
                }
            }, 30000);
        };

        // Start Recording (duration defined, flash remains on)
        startRecordBtn.onclick = () => {
            if (!isMonitoring || isRecording) {
                alert('Start SQM first or recording already in progress.');
                return;
            }
            signal = []; // Reset for recording
            recordingStartTime = Date.now();
            startTime = recordingStartTime;
            isRecording = true;
            recordingEl.style.display = 'block';
            downloadBtn.disabled = true;
            const durationMs = parseInt(durationEl.value) * 1000;
            recordingTimer = setTimeout(() => {
                stopRecording();
                stop();
            }, durationMs);
            logDebug('Recording started');
        };

        function stopRecording() {
            if (recordingTimer) {
                clearTimeout(recordingTimer);
                recordingTimer = null;
            }
            isRecording = false;
            recordingEl.style.display = 'none';
            downloadBtn.disabled = signal.length === 0;
            logDebug('Recording complete: ' + signal.length + ' samples');
        }

        // Stop
        stopBtn.onclick = stop;
        function stop() {
            if (samplingTimer) {
                clearInterval(samplingTimer);
                samplingTimer = null;
            }
            if (isRecording) stopRecording();
            if (torchTrack) {
                torchTrack.applyConstraints({ advanced: [{ torch: false }] }).catch(e => {
                    logDebug('Flash disable failed: ' + e.message);
                });
            }
            isMonitoring = false;
            startMonitorBtn.disabled = !!stream;
            startRecordBtn.disabled = true;
            calibrateBtn.disabled = !stream;
            monitorStatusEl.textContent = stream ? 'Stopped. Ready for ZLO or SQM.' : 'Stopped. Start Camera to continue.';
            logDebug('Stopped');
        }

        // Calibrate ZLO (no flash)
        calibrateBtn.onclick = async () => {
            if (!stream || isMonitoring) {
                alert('Start camera first and stop SQM if running.');
                return;
            }
            calibrateBtn.disabled = true;
            let wasTorchOn = false;
            if (platform === 'Android' && torchTrack) {
                try {
                    await torchTrack.applyConstraints({ advanced: [{ torch: false }] });
                    wasTorchOn = true;
                    logDebug('Flash disabled for ZLO');
                } catch (e) {
                    logDebug('Flash disable failed for ZLO: ' + e.message);
                }
            }
            const calStart = Date.now();
            let sumR = 0, sumG = 0, sumB = 0;
            let calCount = 0;
            const calInterval = setInterval(() => {
                const { r, g, b } = getROIRGB();
                sumR += r + zlo.r; // Raw values
                sumG += g + zlo.g;
                sumB += b + zlo.b;
                calCount++;
                if (Date.now() - calStart >= 2000) {
                    clearInterval(calInterval);
                    zlo = {
                        r: sumR / calCount,
                        g: sumG / calCount,
                        b: sumB / calCount
                    };
                    alert(`ZLO calibrated: R=${zlo.r.toFixed(2)}, G=${zlo.g.toFixed(2)}, B=${zlo.b.toFixed(2)}`);
                    calibrateBtn.disabled = false;
                    logDebug(`ZLO: R=${zlo.r.toFixed(2)}, G=${zlo.g.toFixed(2)}, B=${zlo.b.toFixed(2)}`);
                    if (wasTorchOn) {
                        torchTrack.applyConstraints({ advanced: [{ torch: true }] }).catch(e => {
                            logDebug('Flash re-enable failed: ' + e.message);
                        });
                    }
                }
            }, 100);
        };

        // Reset
        resetBtn.onclick = () => {
            stop();
            signal = [];
            zlo = { r: 0, g: 0, b: 0 };
            startRecordBtn.disabled = true;
            downloadBtn.disabled = true;
            recordingEl.style.display = 'none';
            hrEl.textContent = '--';
            snrEl.textContent = '--';
            strengthEl.textContent = '--';
            dcEl.textContent = '--';
            monitorStatusEl.textContent = `${platform} selected - click Start Camera`;
            plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);
            logDebug('Reset');
        };

        // Download PPG in JSON format matching ppgformat.txt
        downloadBtn.onclick = () => {
            if (signal.length === 0) {
                alert('No data to download.');
                return;
            }
            const ppgSignals = signal.map(s => {
                const signals = new Array(30).fill(0);
                // Mimic the pattern: 10 sets of RGB, where each set has 3 values (R, G, B)
                signals[0] = s.r; signals[1] = s.g; signals[2] = s.b;
                signals[3] = s.r; signals[4] = s.g; signals[5] = s.b;
                signals[6] = s.r; signals[7] = s.g; signals[8] = s.b;
                signals[9] = s.r; signals[10] = s.g; signals[11] = s.b;
                signals[12] = s.r; signals[13] = s.g; signals[14] = s.b;
                signals[15] = s.r; signals[16] = s.g; signals[17] = s.b;
                signals[18] = s.r; signals[19] = s.g; signals[20] = s.b;
                signals[21] = s.r; signals[22] = s.g; signals[23] = s.b;
                signals[24] = s.r; signals[25] = s.g; signals[26] = s.b;
                signals[27] = 0; signals[28] = 0; signals[29] = 0;
                return {
                    Timestamp: Math.floor(recordingStartTime * 1000 + s.time * 1000000),
                    Signals: signals,
                    QualityWarning: s.g < 10 || s.g > 200 // Basic quality check
                };
            });
            const data = {
                PhoneModel: `${platform}|Unknown Device`,
                PhoneOSVersion: 'Unknown',
                InfoSupportedHardwareLevel: 'True',
                PpgSignals: ppgSignals,
                Calibration: null
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ppg_data.json';
            a.click();
            URL.revokeObjectURL(url);
            logDebug('Downloaded JSON with ' + ppgSignals.length + ' entries');
        };

        // Update ROI on resize
        window.addEventListener('resize', updateROIOverlay);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>